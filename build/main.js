var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/interactivate/node_modules/interactivate/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./interactivate.js\"}\n//@ sourceURL=/interactivate/node_modules/interactivate/package.json"
));

require.define("/interactivate/node_modules/interactivate/interactivate.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar diff = require(\"diffpatcher/diff\")\nvar patch = require(\"diffpatcher/patch\")\nvar render = require(\"./render\")\nvar output = require(\"./output\")\nvar makeOutput = output.makeOutput\nvar writeOutput = output.write\n\n\nvar Out = \"out@interactivate\"\nvar In = \"in@interactivate\"\nvar Reciever = \"receiver@interactivate\"\n\nfunction makeOptionGetter(name) {\n  return function getOption(editor) {\n    return editor.getOption(name)\n  }\n}\n\nvar getRenderRate = makeOptionGetter(\"interactiveSpeed\")\nvar getSectionSeparator = makeOptionGetter(\"interactiveSeparator\")\n\n\nvar slicer = Array.prototype.slice\nfunction throttle(f, delay) {\n  /**\n  Creates function that calls throttles calls to given `f` such that,\n  it's only called if no further calls are made with in the time\n  frame (in miliseconds) returned by given `delay.apply(this, arguments)`\n  function.\n  **/\n  var id = 0\n  return function throttled() {\n    clearTimeout(id, throttled)\n    var ms = delay.apply(this, arguments) || 0\n    id = setTimeout.apply(this, [f, ms].concat(slicer.call(arguments)))\n  }\n}\n\n\n\nfunction calculate(editor) {\n  var state = editor[In]\n  var input = editor.getValue()\n  var separator = getSectionSeparator(editor)\n  var sections = input.split(separator)\n  var activeLine = editor.getCursor().line\n\n  sections.pop() // last section does not has execution marker so skip it.\n\n  var change = Object.keys(sections).reduce(function(result, index) {\n    var input = sections[index]\n    var line = result.line + input.split(\"\\n\").length - 1\n    result.line = line\n    var delta = {input: input.trim(), line: line, visible: activeLine !== line}\n    result.state[index] = state[index] ? patch(state[index], delta) :\n                          delta\n\n    return result\n  }, { line: 0, state: {} })\n\n  return diff(editor[In], change.state)\n}\n\n\nfunction send(packet) {\n  var event = document.createEvent(\"CustomEvent\")\n  event.initCustomEvent(\"server\", false, true, packet)\n  window.dispatchEvent(event)\n}\n\n\nfunction recieve(editor, event) {\n  var packet = event.detail\n  var delta = {}\n  delta[packet.from] = {pending: null,\n                        result: render(packet.message)}\n  write(editor, delta)\n}\n\nfunction print(editor) {\n  if (!editor.getOption(\"interactivate\")) throw editor.constructor.Pass\n  editor.operation(function() {\n    var cursor = editor.getCursor()\n    editor.replaceSelection(\"\\n// =>\\n\")\n    editor.setCursor({ line: cursor.line + 2, ch: 0 })\n  })\n}\n\n\nfunction getMarkerFor(editor, view) {\n  var markers = editor.getAllMarks()\n  var count = markers.length\n  while (count) {\n    count = count - 1\n    var marker = markers[count]\n    if (marker.replacedWith === view) return marker\n  }\n  return null\n}\n\n\nfunction write(editor, changes) {\n  console.log(\"<<<\", changes)\n  var doc = editor.getDoc()\n  Object.keys(changes).sort().reduce(function(_, id) {\n    if (!editor[Out][id]) editor[Out][id] = makeOutput(id)\n\n    var output = editor[Out][id]\n    var change = changes[id]\n    if (change === null) editor[Out][id] = null\n\n    writeOutput(output, editor, change)\n  }, null)\n  editor[In] = patch(editor[In], changes)\n}\n\nfunction post(changes) {\n  Object.keys(changes).reduce(function(_, id) {\n    var change = changes[id]\n    if (change && change.input) {\n      console.log(\">>\", id, change)\n      send({ to: id, source: change.input })\n    }\n  }, null)\n}\n\n// Function finds modified sections and queues up messegase to an\n// eval host. In adition it also renders output views (if they\n// do not exist yet) where eval results are written.\nvar renderOutput = throttle(function render(editor) {\n  var delta = calculate(editor)\n  var changes = Object.keys(delta).reduce(function(changes, id) {\n    var change = delta[id]\n    // Only mark change pending if there is some input to be evaled.\n    if (change && change.input) change.pending = true\n    return changes\n  }, delta)\n\n  write(editor, changes)\n  post(changes)\n}, getRenderRate)\n\nvar hideOutput = throttle(function render(editor) {\n  var line = editor.getCursor().line\n  var state = editor[In]\n  var changes = Object.keys(state).reduce(function(delta, id) {\n    var value = state[id]\n    if (value.line === line) delta[id] = {visible: false}\n    else if (!value.visible) delta[id] = {visible: true, line: value.line}\n\n    return delta\n  }, [])\n\n  if (changes.length) write(editor, changes)\n}, function() { return 200 })\n\n\nfunction tooglePlugin(editor, value) {\n  if (value) {\n    editor[Reciever] = recieve.bind(recieve, editor)\n    editor[In] = {}\n    editor[Out] = {}\n    editor.on(\"change\", renderOutput)\n    editor.on(\"cursorActivity\", hideOutput)\n    window.addEventListener(\"client\", editor[Reciever], false)\n  } else {\n    editor.off(\"change\", renderOutput)\n    editor.off(\"cursorActivity\", hideOutput)\n    window.removeEventListener(\"client\", editor[Reciever], false)\n    editor[Reciever] = null\n    editor[In] = null\n    editor[Out] = null\n  }\n}\n\nfunction install(CodeMirror) {\n  // Fix constructor property so that it could be accessed from the\n  // instance.\n  CodeMirror.prototype.constructor = CodeMirror;\n  CodeMirror.defaults.interactiveSpeed = 300\n  CodeMirror.defaults.interactiveSeparator = /^\\/\\/ \\=\\>[^\\n]*$/m\n  CodeMirror.keyMap.macDefault[\"Cmd-Enter\"] = print\n  CodeMirror.keyMap.pcDefault[\"Ctrl-Enter\"] = print\n\n  CodeMirror.defineOption(\"interactivate\", false, tooglePlugin)\n}\n\nmodule.exports = install\n\n//@ sourceURL=/interactivate/node_modules/interactivate/interactivate.js"
));

require.define("/interactivate/node_modules/interactivate/node_modules/diffpatcher/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/interactivate/node_modules/interactivate/node_modules/diffpatcher/package.json"
));

require.define("/interactivate/node_modules/interactivate/node_modules/diffpatcher/diff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state should return object representing `delta`\n// that has being applied to a previous state to get to a current state.\n//\n// Example\n//\n// diff(state) // => { \"item-id-1\": { title: \"some title\" } \"item-id-2\": null }\nvar diff = method(\"diff\")\n\n// diff between `null` / `undefined` to any hash is a hash itself.\ndiff.define(null, function(from, to) { return to })\ndiff.define(undefined, function(from, to) { return to })\ndiff.define(Object, function(from, to) {\n  return calculate(from, to || {}) || {}\n})\n\nfunction calculate(from, to) {\n  var diff = {}\n  var changes = 0\n  Object.keys(from).forEach(function(key) {\n    changes = changes + 1\n    if (!(key in to) && from[key] != null) diff[key] = null\n    else changes = changes - 1\n  })\n  Object.keys(to).forEach(function(key) {\n    changes = changes + 1\n    var previous = from[key]\n    var current = to[key]\n    if (previous === current) return (changes = changes - 1)\n    if (typeof(current) !== \"object\") return diff[key] = current\n    if (typeof(previous) !== \"object\") return diff[key] = current\n    var delta = calculate(previous, current)\n    if (delta) diff[key] = delta\n    else changes = changes - 1\n  })\n  return changes ? diff : null\n}\n\ndiff.calculate = calculate\n\nmodule.exports = diff\n\n//@ sourceURL=/interactivate/node_modules/interactivate/node_modules/diffpatcher/diff.js"
));

require.define("/interactivate/node_modules/interactivate/node_modules/method/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/interactivate/node_modules/interactivate/node_modules/method/package.json"
));

require.define("/interactivate/node_modules/interactivate/node_modules/method/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\n\n// Shortcut for `Object.prototype.toString` for faster access.\nvar typefy = Object.prototype.toString\n\n// Map to for jumping from typeof(value) to associated type prefix used\n// as a hash in the map of builtin implementations.\nvar types = { \"function\": \"Object\", \"object\": \"Object\" }\n\n// Array is used to save method implementations for the host objects in order\n// to avoid extending them with non-primitive values that could cause leaks.\nvar host = []\n// Hash map is used to save method implementations for builtin types in order\n// to avoid extending their prototypes. This also allows to share method\n// implementations for types across diff contexts / frames / compartments.\nvar builtin = {}\n\nfunction Primitive() {}\nfunction ObjectType() {}\nObjectType.prototype = new Primitive()\nfunction ErrorType() {}\nErrorType.prototype = new ObjectType()\n\nvar Default = builtin.Default = Primitive.prototype\nvar Null = builtin.Null = new Primitive()\nvar Void = builtin.Void = new Primitive()\nbuiltin.String = new Primitive()\nbuiltin.Number = new Primitive()\nbuiltin.Boolean = new Primitive()\n\nbuiltin.Object = ObjectType.prototype\nbuiltin.Error = ErrorType.prototype\n\nbuiltin.EvalError = new ErrorType()\nbuiltin.InternalError = new ErrorType()\nbuiltin.RangeError = new ErrorType()\nbuiltin.ReferenceError = new ErrorType()\nbuiltin.StopIteration = new ErrorType()\nbuiltin.SyntaxError = new ErrorType()\nbuiltin.TypeError = new ErrorType()\nbuiltin.URIError = new ErrorType()\n\n\nfunction Method(id) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method:\n\n      method(object, ...rest) => object[method](...rest)\n\n  It is supposed to be given **unique** `id` preferably in `\"jump@package\"`\n  like form so it won't collide with `id's` other users create. If no argument\n  is passed unique id is generated, but it's proved to be problematic with\n  npm where it's easy to end up with a copies of same module where each copy\n  will have a different name.\n\n  ## Example\n\n      var foo = Method(\"foo@awesomeness\")\n\n      // Implementation for any types\n      foo.define(function(value, arg1, arg2) {\n        // ...\n      })\n\n      // Implementation for a specific type\n      foo.define(BarType, function(bar, arg1, arg2) {\n        // ...\n      })\n  **/\n\n  // Create an internal unique name if one is not provided, also prefix it\n  // to avoid collision with regular method names.\n  var name = \"Î»:\" + String(id || Math.random().toString(32).substr(2))\n\n  function dispatch(value) {\n    // Method dispatches on type of the first argument.\n    // If first argument is `null` or `void` associated implementation is\n    // looked up in the `builtin` hash where implementations for built-ins\n    // are stored.\n    var type = null\n    var method = value === null ? Null[name] :\n                 value === void(0) ? Void[name] :\n                 // Otherwise attempt to use method with a generated private\n                 // `name` that is supposedly in the prototype chain of the\n                 // `target`.\n                 value[name] ||\n                 // Otherwise assume it's one of the built-in type instances,\n                 // in which case implementation is stored in a `builtin` hash.\n                 // Attempt to find a implementation for the given built-in\n                 // via constructor name and method name.\n                 ((type = builtin[(value.constructor || \"\").name]) &&\n                  type[name]) ||\n                 // Otherwise assume it's a host object. For host objects\n                 // actual method implementations are stored in the `host`\n                 // array and only index for the implementation is stored\n                 // in the host object's prototype chain. This avoids memory\n                 // leaks that otherwise could happen when saving JS objects\n                 // on host object.\n                 host[value[\"!\" + name]] ||\n                 // Otherwise attempt to lookup implementation for builtins by\n                 // a type of the value. This basically makes sure that all\n                 // non primitive values will delegate to an `Object`.\n                 ((type = builtin[types[typeof(value)]]) && type[name])\n\n\n    // If method implementation for the type is still not found then\n    // just fallback for default implementation.\n    method = method || Default[name]\n\n    // If implementation is still not found (which also means there is no\n    // default) just throw an error with a descriptive message.\n    if (!method) throw TypeError(\"Type does not implements method: \" + name)\n\n    // If implementation was found then just delegate.\n    return method.apply(method, arguments)\n  }\n\n  // Make `toString` of the dispatch return a private name, this enables\n  // method definition without sugar:\n  //\n  //    var method = Method()\n  //    object[method] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Create method shortcuts form functions.\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda)\n}\n\n// Define `implement` and `define` polymorphic methods to allow definitions\n// and implementations through them.\nvar implement = Method(\"implement@method\")\nvar define = Method(\"define@method\")\n\n\nfunction _implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  return defineProperty(object, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n}\n\nfunction _define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n\n  // Attempt to guess a type via `Object.prototype.toString.call` hack.\n  var type = Type && typefy.call(Type.prototype)\n\n  // If only two arguments are passed then `Type` is actually an implementation\n  // for a default type.\n  if (!lambda) Default[method] = Type\n  // If `Type` is `null` or `void` store implementation accordingly.\n  else if (Type === null) Null[method] = lambda\n  else if (Type === void(0)) Void[method] = lambda\n  // If `type` hack indicates built-in type and type has a name us it to\n  // store a implementation into associated hash. If hash for this type does\n  // not exists yet create one.\n  else if (type !== \"[object Object]\" && Type.name) {\n    var Bulitin = builtin[Type.name] || (builtin[Type.name] = new ObjectType())\n    Bulitin[method] = lambda\n  }\n  // If `type` hack indicates an object, that may be either object or any\n  // JS defined \"Class\". If name of the constructor is `Object`, assume it's\n  // built-in `Object` and store implementation accordingly.\n  else if (Type.name === \"Object\")\n    builtin.Object[method] = lambda\n  // Host objects are pain!!! Every browser does some crazy stuff for them\n  // So far all browser seem to not implement `call` method for host object\n  // constructors. If that is a case here, assume it's a host object and\n  // store implementation in a `host` array and store `index` in the array\n  // in a `Type.prototype` itself. This avoids memory leaks that could be\n  // caused by storing JS objects on a host objects.\n  else if (Type.call === void(0)) {\n    var index = host.indexOf(lambda)\n    if (index < 0) index = host.push(lambda) - 1\n    // Prefix private name with `!` so it can be dispatched from the method\n    // without type checks.\n    implement(\"!\" + method, Type.prototype, index)\n  }\n  // If Got that far `Type` is user defined JS `Class`. Define private name\n  // as hidden property on it's prototype.\n  else\n    implement(method, Type.prototype, lambda)\n}\n\n// And provided implementations for a polymorphic equivalents.\n_define(define, _define)\n_define(implement, _implement)\n\n// Define exports on `Method` as it's only thing being exported.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.method = Method\nMethod.builtin = builtin\nMethod.host = host\n\nmodule.exports = Method\n\n//@ sourceURL=/interactivate/node_modules/interactivate/node_modules/method/core.js"
));

require.define("/interactivate/node_modules/interactivate/node_modules/diffpatcher/patch.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\nvar rebase = require(\"./rebase\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state and delta should return object representing\n// new state, with changes in `delta` being applied to previous.\n//\n// ## Example\n//\n// patch(state, {\n//   \"item-id-1\": { completed: false }, // update\n//   \"item-id-2\": null                  // delete\n// })\nvar patch = method(\"patch\")\npatch.define(Object, function patch(hash, delta) {\n  return rebase({}, hash, delta)\n})\n\nmodule.exports = patch\n\n//@ sourceURL=/interactivate/node_modules/interactivate/node_modules/diffpatcher/patch.js"
));

require.define("/interactivate/node_modules/interactivate/node_modules/diffpatcher/rebase.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nfunction rebase(result, parent, delta) {\n  Object.keys(parent).forEach(function(key) {\n    // If `parent[key]` is `null` it means attribute was deleted in previous\n    // update. We skip such properties as there is no use in keeping them\n    // around. If `delta[key]` is `null` we skip these properties too as\n    // the have being deleted.\n    if (!(parent[key] == null || (key in delta && delta[key] == null)))\n      result[key] = parent[key]\n  }, result)\n  Object.keys(delta).forEach(function(key) {\n    if (key in parent) {\n      var current = delta[key]\n      var previous = parent[key]\n      if (current === previous) current = current\n      // If `delta[key]` is `null` it's delete so we just skip property.\n      else if (current == null) current = current\n      // If value is of primitive type (function or regexps should not\n      // even be here) we just update in place.\n      else if (typeof(current) !== \"object\") result[key] = current\n      // If previous value associated with this key was primitive\n      // and it's mapped to non primitive\n      else if (typeof(previous) !== \"object\") result[key] = current\n      else result[key] = rebase({}, previous, current)\n    } else {\n      result[key] = delta[key]\n    }\n  })\n  return result\n}\n\nmodule.exports = rebase\n\n//@ sourceURL=/interactivate/node_modules/interactivate/node_modules/diffpatcher/rebase.js"
));

require.define("/interactivate/node_modules/interactivate/render.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\nvar util = require(\"util\")\n\n\n// Render function takes arbitrary data structure and returns something\n// that can visually represent it.\nvar render = method(\"render@interactivate\")\n\nrender.define(function(value) {\n  return util.inspect(value)\n})\n\nrender.define(Error, function(error) {\n  return String(error)\n})\n\nrender.define(Element, function(element) {\n  return element\n})\n\nmodule.exports = render\n\n//@ sourceURL=/interactivate/node_modules/interactivate/render.js"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("/interactivate/node_modules/interactivate/output.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var makeView = require(\"./view\").makeView\n\nfunction Output(id) {\n  this.id = id\n}\n\nfunction makeOutput(id) {\n  return new Output(id)\n}\n\n\nfunction clear(output) {\n  output.marker.clear()\n  output.widget.clear()\n}\n\nfunction mark(output, editor, line) {\n  output.marker = editor.markText({line: line, ch: 0},\n                                  {line: line},\n                                  {collapsed: true,\n                                   inclusiveLeft: false,\n                                   inclusiveRight: true,\n                                   })\n\n  output.widget = editor.addLineWidget(line,\n                                       output.view,\n                                       {showIfHidden: true,\n                                        noHScroll:true})\n}\n\nfunction move(output, editor, line) {\n  var position = output.marker.find()\n  if (!position || position.line !== line) {\n    clear(output)\n    mark(output, editor, line)\n  }\n}\n\nfunction write(output, editor, state) {\n  var view = output.view || (output.view = makeView(editor, output.id))\n  if (state === null) return clear(output)\n\n  if (state.pending) output.view.style.opacity = \"0.2\"\n  else if (state.pending === null) output.view.style.opacity = \"\"\n\n  if (state.result) {\n    var content = state.result\n    view.body.innerHTML = \"\"\n    if (content instanceof Element) view.body.appendChild(content)\n    else view.body.textContent = content\n  }\n\n  if (state.visible === true) mark(output, editor, state.line)\n  if (state.visible === false) clear(output)\n  if (state.line) move(output, editor, state.line)\n}\n\nexports.makeOutput = makeOutput\nexports.write = write\n//@ sourceURL=/interactivate/node_modules/interactivate/output.js"
));

require.define("/interactivate/node_modules/interactivate/view.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var TEAR_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAMCAYAAABBV8wuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGpJREFUeNpi/P//PwM2wMSAA7CACEYggLKZgfgvEP8BCYAwKxALAjEPEH8B4g9MUI5IWlqayevXr9eCaCBfGGSSVnJysu/Xr1+fAx3y/9u3by9BfIb29vZCmCAMgCQZ/+NwL07nUlECIMAAMr41sxvv6oEAAAAASUVORK5CYII=\"\n\nvar OUTPUT_STYLE = [\n  \"margin-left: -10px\",\n  \"padding: 0\",\n  \"whitespace: normal\",\n  \"text-shadow: none\"\n].join(\";\")\n\nvar TOP_STYLE = [\n  \"position: relative\",\n  \"z-index: 2\",\n  \"height: 12px\",\n  \"background-clip: padding-box\",\n  \"background: url('\" + TEAR_IMAGE + \"') top right repeat-x\"\n].join(\";\")\n\nvar BOTTOM_STYLE = [\n  \"position: relative\",\n  \"z-index: 2\",\n  \"height: 12px\",\n  \"background-clip: padding-box\",\n  \"background: url('\" + TEAR_IMAGE + \"') top left repeat-x\",\n  \"-webkit-transform: rotate(180deg)\",\n  \"-o-transform: rotate(180deg)\",\n  \"transform: rotate(180deg)\"\n].join(\";\")\n\nvar BOX_STYLE = [\n  \"-moz-box-shadow: 0 0 30px -2px #000\",\n  \"-webkit-box-shadow: 0 0 30px -2px #000\",\n  \"box-shadow: 0 0 30px -2px #000\",\n  \"color: black\",\n  \"background: white\",\n  \"position: relative\",\n  \"margin: 0px\",\n  \"width: 100%\"\n].join(\";\")\n\nvar HEAD_STYLE = [\n  \"display: table-cell\",\n  \"padding: 10px\",\n  \"padding-left: 20px\",\n  \"white-space: pre\",\n  \"color: white\",\n  \"text-shadow: 0px 1px 5px #000\",\n  \"vertical-align: top\"\n].join(\";\")\n\nvar BODY_STYLE = [\n  \"display: table-cell\",\n  \"padding: 10px\",\n  \"width: 100%\"\n].join(\";\")\n\nvar TEMPLATE = [\n  \"<div style=\\\"\" + OUTPUT_STYLE + \"\\\">\",\n  \"  <div class='cm-live-output-border-top' style=\\\"\" + TOP_STYLE + \"\\\"> </div>\",\n  \"  <div class='cm-live-output-box' style=\\\"\" + BOX_STYLE + \"\\\">\",\n  \"    <h1 class='cm-live-output-head' style=\\\"\" + HEAD_STYLE + \"\\\">Out[0]</h1>\",\n  \"    <pre class='cm-live-output-body' style=\\\"\" + BODY_STYLE + \"\\\"></pre>\",\n  \"  </div>\",\n  \"  <div class='cm-live-output-border-bottom' style=\\\"\" + BOTTOM_STYLE + \"\\\"></div>\",\n  \"</div>\"\n ].join(\"\\n\")\n\nfunction makeView(editor, id) {\n  var document = editor.display.input.ownerDocument\n  var container = document.createElement(\"section\")\n  container.innerHTML = TEMPLATE\n  var view = container.firstChild\n  view.id = \"interactivate-out-\" + id\n  view.label = view.querySelector(\".cm-live-output-head\")\n  view.label.textContent = \"Out[\" + id + \"] = \"\n  view.body = view.querySelector(\".cm-live-output-body\")\n  return view\n}\n\nexports.makeView = makeView\n//@ sourceURL=/interactivate/node_modules/interactivate/view.js"
));

require.define("/interactivate/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./main.js\"}\n//@ sourceURL=/interactivate/package.json"
));

require.define("/interactivate/host.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var read_ = (require(\"../lib/reader\")).read_;;\n\nvar compile_ = (require(\"../lib/compiler\")).compile_;;\n\nvar rest = (require(\"../lib/sequence\")).rest;;\n\nvar __out__ = function __out__() {\n  return void(0);\n};\nexports.__out__ = __out__;\n\nwindow.exports = {};\n\nwindow.Out = __out__;\n\nvar send = function send(packet) {\n  var event = document.createEvent(\"CustomEvent\");\n  event.initCustomEvent(\"client\", false, true, packet);\n  return window.dispatchEvent(event);\n};\nexports.send = send;\n\nvar startHost = function startHost() {\n  return window.addEventListener(\"server\", handle, false);\n};\nexports.startHost = startHost;\n\nvar handle = function handle(packet) {\n  var address = (((packet || 0)[\"detail\"]) || 0)[\"to\"];\n  var input = (((packet || 0)[\"detail\"]) || 0)[\"source\"];\n  var output = evaluate(input);\n  var result = represent(output);\n  __out__[address] = result;\n  return send({\n    \"from\": address,\n    \"message\": result\n  });\n};\nexports.handle = handle;\n\nvar evaluate = function evaluate(input) {\n  return (function() {\n  try {\n    return (function() {\n      var forms = read_(input);\n      var jsCode = compile_(forms);\n      var result = window.eval(jsCode);\n      return {\n        \"input\": input,\n        \"forms\": forms,\n        \"js-code\": jsCode,\n        \"result\": result\n      };\n    })();\n  } catch (error) {\n    return {\n      \"input\": input,\n      \"error\": error\n    };\n  }})();\n};\nexports.evaluate = evaluate;\n\nvar represent = function represent(output) {\n  return ((output || 0)[\"error\"]) || ((output || 0)[\"result\"]);\n};\nexports.represent = represent\n\n//@ sourceURL=/interactivate/host.js"
));

require.define("/lib/reader.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var lazySeq = (require(\"./sequence\")).lazySeq;\nvar sort = (require(\"./sequence\")).sort;\nvar butlast = (require(\"./sequence\")).butlast;\nvar last = (require(\"./sequence\")).last;\nvar concat = (require(\"./sequence\")).concat;\nvar rest = (require(\"./sequence\")).rest;\nvar conj = (require(\"./sequence\")).conj;\nvar cons = (require(\"./sequence\")).cons;\nvar vec = (require(\"./sequence\")).vec;\nvar map = (require(\"./sequence\")).map;\nvar rest = (require(\"./sequence\")).rest;\nvar third = (require(\"./sequence\")).third;\nvar second = (require(\"./sequence\")).second;\nvar first = (require(\"./sequence\")).first;\nvar isEmpty = (require(\"./sequence\")).isEmpty;\nvar count = (require(\"./sequence\")).count;\nvar isList = (require(\"./sequence\")).isList;\nvar list = (require(\"./sequence\")).list;;\n\nvar isStrictEqual = (require(\"./runtime\")).isStrictEqual;\nvar isEqual = (require(\"./runtime\")).isEqual;\nvar vals = (require(\"./runtime\")).vals;\nvar char = (require(\"./runtime\")).char;\nvar subs = (require(\"./runtime\")).subs;\nvar str = (require(\"./runtime\")).str;\nvar reFind = (require(\"./runtime\")).reFind;\nvar reMatches = (require(\"./runtime\")).reMatches;\nvar rePattern = (require(\"./runtime\")).rePattern;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isObject = (require(\"./runtime\")).isObject;\nvar isBoolean = (require(\"./runtime\")).isBoolean;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isString = (require(\"./runtime\")).isString;\nvar isVector = (require(\"./runtime\")).isVector;\nvar dec = (require(\"./runtime\")).dec;\nvar inc = (require(\"./runtime\")).inc;\nvar isNil = (require(\"./runtime\")).isNil;\nvar keys = (require(\"./runtime\")).keys;\nvar dictionary = (require(\"./runtime\")).dictionary;\nvar isOdd = (require(\"./runtime\")).isOdd;;\n\nvar gensym = (require(\"./ast\")).gensym;\nvar name = (require(\"./ast\")).name;\nvar withMeta = (require(\"./ast\")).withMeta;\nvar meta = (require(\"./ast\")).meta;\nvar keyword = (require(\"./ast\")).keyword;\nvar isKeyword = (require(\"./ast\")).isKeyword;\nvar symbol = (require(\"./ast\")).symbol;\nvar isSymbol = (require(\"./ast\")).isSymbol;;\n\nvar join = (require(\"./string\")).join;\nvar split = (require(\"./string\")).split;;\n\nvar pushBackReader = function pushBackReader(source, uri) {\n  return {\n    \"lines\": split(source, \"\\n\"),\n    \"buffer\": \"\",\n    \"uri\": uri,\n    \"column\": -1,\n    \"line\": 0\n  };\n};\nexports.pushBackReader = pushBackReader;\n\nvar peekChar = function peekChar(reader) {\n  var line = ((reader || 0)[\"lines\"])[(reader || 0)[\"line\"]];\n  var column = inc((reader || 0)[\"column\"]);\n  return isNil(line) ?\n    void(0) :\n    (line[column]) || \"\\n\";\n};\nexports.peekChar = peekChar;\n\nvar readChar = function readChar(reader) {\n  var ch = peekChar(reader);\n  isNewline(peekChar(reader)) ?\n    (function() {\n      (reader || 0)[\"line\"] = inc((reader || 0)[\"line\"]);\n      return (reader || 0)[\"column\"] = -1;\n    })() :\n    (reader || 0)[\"column\"] = inc((reader || 0)[\"column\"]);\n  return ch;\n};\nexports.readChar = readChar;\n\nvar isNewline = function isNewline(ch) {\n  return \"\\n\" === ch;\n};\nexports.isNewline = isNewline;\n\nvar isBreakingWhitespace = function isBreakingWhitespace(ch) {\n  return (ch === \" \") || (ch === \"\\t\") || (ch === \"\\n\") || (ch === \"\\r\");\n};\nexports.isBreakingWhitespace = isBreakingWhitespace;\n\nvar isWhitespace = function isWhitespace(ch) {\n  return (isBreakingWhitespace(ch)) || (\",\" === ch);\n};\nexports.isWhitespace = isWhitespace;\n\nvar isNumeric = function isNumeric(ch) {\n  return (ch === \"0\") || (ch === \"1\") || (ch === \"2\") || (ch === \"3\") || (ch === \"4\") || (ch === \"5\") || (ch === \"6\") || (ch === \"7\") || (ch === \"8\") || (ch === \"9\");\n};\nexports.isNumeric = isNumeric;\n\nvar isCommentPrefix = function isCommentPrefix(ch) {\n  return \";\" === ch;\n};\nexports.isCommentPrefix = isCommentPrefix;\n\nvar isNumberLiteral = function isNumberLiteral(reader, initch) {\n  return (isNumeric(initch)) || (((\"+\" === initch) || (\"-\" === initch)) && (isNumeric(peekChar(reader))));\n};\nexports.isNumberLiteral = isNumberLiteral;\n\nvar readerError = function readerError(reader, message) {\n  var text = \"\" + message + \"\\n\" + \"line:\" + ((reader || 0)[\"line\"]) + \"\\n\" + \"column:\" + ((reader || 0)[\"column\"]);\n  var error = SyntaxError(text, (reader || 0)[\"uri\"]);\n  error.line = (reader || 0)[\"line\"];\n  error.column = (reader || 0)[\"column\"];\n  error.uri = (reader || 0)[\"uri\"];\n  return (function() { throw error; })();\n};\nexports.readerError = readerError;\n\nvar isMacroTerminating = function isMacroTerminating(ch) {\n  return (!(ch === \"#\")) && (!(ch === \"'\")) && (!(ch === \":\")) && (macros(ch));\n};\nexports.isMacroTerminating = isMacroTerminating;\n\nvar readToken = function readToken(reader, initch) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (isNil(ch)) || (isWhitespace(ch)) || (isMacroTerminating(ch)) ?\n      buffer :\n      (buffer = \"\" + buffer + (readChar(reader)), ch = peekChar(reader), loop);\n    };\n    return recur;\n  })(initch, peekChar(reader));\n};\nexports.readToken = readToken;\n\nvar skipLine = function skipLine(reader, _) {\n  return (function loop() {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (function() {\n      var ch = readChar(reader);\n      return (ch === \"\\n\") || (ch === \"\\r\") || (isNil(ch)) ?\n        reader :\n        (loop);\n    })();\n    };\n    return recur;\n  })();\n};\nexports.skipLine = skipLine;\n\nvar intPattern = rePattern(\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\");\nexports.intPattern = intPattern;\n\nvar ratioPattern = rePattern(\"([-+]?[0-9]+)/([0-9]+)\");\nexports.ratioPattern = ratioPattern;\n\nvar floatPattern = rePattern(\"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\");\nexports.floatPattern = floatPattern;\n\nvar matchInt = function matchInt(s) {\n  var groups = reFind(intPattern, s);\n  var group3 = groups[2];\n  return !((isNil(group3)) || (count(group3) < 1)) ?\n    0 :\n    (function() {\n      var negate = \"-\" === groups[1] ?\n        -1 :\n        1;\n      var a = groups[3] ?\n        [groups[3], 10] :\n      groups[4] ?\n        [groups[4], 16] :\n      groups[5] ?\n        [groups[5], 8] :\n      groups[7] ?\n        [groups[7], parseInt(groups[7])] :\n      \"else\" ?\n        [void(0), void(0)] :\n        void(0);\n      var n = a[0];\n      var radix = a[1];\n      return isNil(n) ?\n        void(0) :\n        negate * (parseInt(n, radix));\n    })();\n};\nexports.matchInt = matchInt;\n\nvar matchRatio = function matchRatio(s) {\n  var groups = reFind(ratioPattern, s);\n  var numinator = groups[1];\n  var denominator = groups[2];\n  return (parseInt(numinator)) / (parseInt(denominator));\n};\nexports.matchRatio = matchRatio;\n\nvar matchFloat = function matchFloat(s) {\n  return parseFloat(s);\n};\nexports.matchFloat = matchFloat;\n\nvar matchNumber = function matchNumber(s) {\n  return reMatches(intPattern, s) ?\n    matchInt(s) :\n  reMatches(ratioPattern, s) ?\n    matchRatio(s) :\n  reMatches(floatPattern, s) ?\n    matchFloat(s) :\n    void(0);\n};\nexports.matchNumber = matchNumber;\n\nvar escapeCharMap = function escapeCharMap(c) {\n  return c === \"t\" ?\n    \"\\t\" :\n  c === \"r\" ?\n    \"\\r\" :\n  c === \"n\" ?\n    \"\\n\" :\n  c === \"\\\\\" ?\n    \"\\\\\" :\n  c === \"\\\"\" ?\n    \"\\\"\" :\n  c === \"b\" ?\n    \"\b\" :\n  c === \"f\" ?\n    \"\f\" :\n  \"else\" ?\n    void(0) :\n    void(0);\n};\nexports.escapeCharMap = escapeCharMap;\n\nvar read2Chars = function read2Chars(reader) {\n  return \"\" + (readChar(reader)) + (readChar(reader));\n};\nexports.read2Chars = read2Chars;\n\nvar read4Chars = function read4Chars(reader) {\n  return \"\" + (readChar(reader)) + (readChar(reader)) + (readChar(reader)) + (readChar(reader));\n};\nexports.read4Chars = read4Chars;\n\nvar unicode2Pattern = rePattern(\"[0-9A-Fa-f]{2}\");\nexports.unicode2Pattern = unicode2Pattern;\n\nvar unicode4Pattern = rePattern(\"[0-9A-Fa-f]{4}\");\nexports.unicode4Pattern = unicode4Pattern;\n\nvar validateUnicodeEscape = function validateUnicodeEscape(unicodePattern, reader, escapeChar, unicodeStr) {\n  return reMatches(unicodePattern, unicodeStr) ?\n    unicodeStr :\n    readerError(reader, \"\" + \"Unexpected unicode escape \" + \"\\\\\" + escapeChar + unicodeStr);\n};\nexports.validateUnicodeEscape = validateUnicodeEscape;\n\nvar makeUnicodeChar = function makeUnicodeChar(codeStr, base) {\n  var base = base || 16;\n  var code = parseInt(codeStr, base);\n  return char(code);\n};\nexports.makeUnicodeChar = makeUnicodeChar;\n\nvar escapeChar = function escapeChar(buffer, reader) {\n  var ch = readChar(reader);\n  var mapresult = escapeCharMap(ch);\n  return mapresult ?\n    mapresult :\n  ch === \"x\" ?\n    makeUnicodeChar(validateUnicodeEscape(unicode2Pattern, reader, ch, read2Chars(reader))) :\n  ch === \"u\" ?\n    makeUnicodeChar(validateUnicodeEscape(unicode4Pattern, reader, ch, read4Chars(reader))) :\n  isNumeric(ch) ?\n    char(ch) :\n  \"else\" ?\n    readerError(reader, \"\" + \"Unexpected unicode escape \" + \"\\\\\" + ch) :\n    void(0);\n};\nexports.escapeChar = escapeChar;\n\nvar readPast = function readPast(predicate, reader) {\n  return (function loop(_) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = predicate(peekChar(reader)) ?\n      (_ = readChar(reader), loop) :\n      peekChar(reader);\n    };\n    return recur;\n  })(void(0));\n};\nexports.readPast = readPast;\n\nvar readDelimitedList = function readDelimitedList(delim, reader, isRecursive) {\n  return (function loop(form) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (function() {\n      var ch = readPast(isWhitespace, reader);\n      !(ch) ?\n        readerError(reader, \"EOF\") :\n        void(0);\n      return delim === ch ?\n        (function() {\n          readChar(reader);\n          return form;\n        })() :\n        (function() {\n          var macro = macros(ch);\n          return macro ?\n            (function() {\n              var result = macro(reader, readChar(reader));\n              return (form = result === reader ?\n                form :\n                conj(form, result), loop);\n            })() :\n            (function() {\n              var o = read(reader, true, void(0), isRecursive);\n              return (form = o === reader ?\n                form :\n                conj(form, o), loop);\n            })();\n        })();\n    })();\n    };\n    return recur;\n  })([]);\n};\nexports.readDelimitedList = readDelimitedList;\n\nvar notImplemented = function notImplemented(reader, ch) {\n  return readerError(reader, \"\" + \"Reader for \" + ch + \" not implemented yet\");\n};\nexports.notImplemented = notImplemented;\n\nvar readDispatch = function readDispatch(reader, _) {\n  var ch = readChar(reader);\n  var dm = dispatchMacros(ch);\n  return dm ?\n    dm(reader, _) :\n    (function() {\n      var object = maybeReadTaggedType(reader, ch);\n      return object ?\n        object :\n        readerError(reader, \"No dispatch macro for \", ch);\n    })();\n};\nexports.readDispatch = readDispatch;\n\nvar readUnmatchedDelimiter = function readUnmatchedDelimiter(rdr, ch) {\n  return readerError(rdr, \"Unmached delimiter \", ch);\n};\nexports.readUnmatchedDelimiter = readUnmatchedDelimiter;\n\nvar readList = function readList(reader, _) {\n  var form = readDelimitedList(\")\", reader, true);\n  return withMeta(list.apply(list, form), meta(form));\n};\nexports.readList = readList;\n\nvar readComment = function readComment(reader, _) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (isNil(ch)) || (\"\\n\" === ch) ?\n      reader || (list(symbol(void(0), \"comment\"), buffer)) :\n    (\"\\\\\" === ch) ?\n      (buffer = \"\" + buffer + (escapeChar(buffer, reader)), ch = readChar(reader), loop) :\n    \"else\" ?\n      (buffer = \"\" + buffer + ch, ch = readChar(reader), loop) :\n      void(0);\n    };\n    return recur;\n  })(\"\", readChar(reader));\n};\nexports.readComment = readComment;\n\nvar readVector = function readVector(reader) {\n  return readDelimitedList(\"]\", reader, true);\n};\nexports.readVector = readVector;\n\nvar readMap = function readMap(reader) {\n  var form = readDelimitedList(\"}\", reader, true);\n  return isOdd(count(form)) ?\n    readerError(reader, \"Map literal must contain an even number of forms\") :\n    withMeta(dictionary.apply(dictionary, form), meta(form));\n};\nexports.readMap = readMap;\n\nvar readSet = function readSet(reader, _) {\n  var form = readDelimitedList(\"}\", reader, true);\n  return withMeta(concat([symbol(void(0), \"set\")], form), meta(form));\n};\nexports.readSet = readSet;\n\nvar readNumber = function readNumber(reader, initch) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (isNil(ch)) || (isWhitespace(ch)) || (macros(ch)) ?\n      (function() {\n        var match = matchNumber(buffer);\n        return isNil(match) ?\n          readerError(reader, \"Invalid number format [\", buffer, \"]\") :\n          match;\n      })() :\n      (buffer = \"\" + buffer + (readChar(reader)), ch = peekChar(reader), loop);\n    };\n    return recur;\n  })(initch, peekChar(reader));\n};\nexports.readNumber = readNumber;\n\nvar readString = function readString(reader) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isNil(ch) ?\n      readerError(reader, \"EOF while reading string\") :\n    \"\\\\\" === ch ?\n      (buffer = \"\" + buffer + (escapeChar(buffer, reader)), ch = readChar(reader), loop) :\n    \"\\\"\" === ch ?\n      buffer :\n    \"default\" ?\n      (buffer = \"\" + buffer + ch, ch = readChar(reader), loop) :\n      void(0);\n    };\n    return recur;\n  })(\"\", readChar(reader));\n};\nexports.readString = readString;\n\nvar readUnquote = function readUnquote(reader) {\n  var ch = peekChar(reader);\n  return !(ch) ?\n    readerError(reader, \"EOF while reading character\") :\n  ch === \"@\" ?\n    (function() {\n      readChar(reader);\n      return list(symbol(void(0), \"unquote-splicing\"), read(reader, true, void(0), true));\n    })() :\n    list(symbol(void(0), \"unquote\"), read(reader, true, void(0), true));\n};\nexports.readUnquote = readUnquote;\n\nvar specialSymbols = function specialSymbols(text, notFound) {\n  return text === \"nil\" ?\n    void(0) :\n  text === \"true\" ?\n    true :\n  text === \"false\" ?\n    false :\n  \"else\" ?\n    notFound :\n    void(0);\n};\nexports.specialSymbols = specialSymbols;\n\nvar readSymbol = function readSymbol(reader, initch) {\n  var token = readToken(reader, initch);\n  var parts = split(token, \"/\");\n  var hasNs = (count(parts) > 1) && (count(token) > 1);\n  var ns = first(parts);\n  var name = join(\"/\", rest(parts));\n  return hasNs ?\n    symbol(ns, name) :\n    specialSymbols(token, symbol(token));\n};\nexports.readSymbol = readSymbol;\n\nvar readKeyword = function readKeyword(reader, initch) {\n  var token = readToken(reader, readChar(reader));\n  var parts = split(token, \"/\");\n  var name = last(parts);\n  var ns = count(parts) > 1 ?\n    join(\"/\", butlast(parts)) :\n    void(0);\n  var issue = last(ns) === \":\" ?\n    \"namespace can't ends with \\\":\\\"\" :\n  last(name) === \":\" ?\n    \"name can't end with \\\":\\\"\" :\n  last(name) === \"/\" ?\n    \"name can't end with \\\"/\\\"\" :\n  count(split(token, \"::\")) > 1 ?\n    \"name can't contain \\\"::\\\"\" :\n    void(0);\n  return issue ?\n    readerError(reader, \"Invalid token (\", issue, \"): \", token) :\n  (!(ns)) && (first(name) === \":\") ?\n    keyword(rest(name)) :\n    keyword(ns, name);\n};\nexports.readKeyword = readKeyword;\n\nvar desugarMeta = function desugarMeta(f) {\n  return isKeyword(f) ?\n    dictionary(name(f), true) :\n  isSymbol(f) ?\n    {\n      \"tag\": f\n    } :\n  isString(f) ?\n    {\n      \"tag\": f\n    } :\n  \"else\" ?\n    f :\n    void(0);\n};\nexports.desugarMeta = desugarMeta;\n\nvar wrappingReader = function wrappingReader(prefix) {\n  return function(reader) {\n    return list(prefix, read(reader, true, void(0), true));\n  };\n};\nexports.wrappingReader = wrappingReader;\n\nvar throwingReader = function throwingReader(msg) {\n  return function(reader) {\n    return readerError(reader, msg);\n  };\n};\nexports.throwingReader = throwingReader;\n\nvar readMeta = function readMeta(reader, _) {\n  var metadata = desugarMeta(read(reader, true, void(0), true));\n  !(isDictionary(metadata)) ?\n    readerError(reader, \"Metadata must be Symbol, Keyword, String or Map\") :\n    void(0);\n  return (function() {\n    var form = read(reader, true, void(0), true);\n    return isObject(form) ?\n      withMeta(form, conj(metadata, meta(form))) :\n      form;\n  })();\n};\nexports.readMeta = readMeta;\n\nvar readRegex = function readRegex(reader) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isNil(ch) ?\n      readerError(reader, \"EOF while reading string\") :\n    \"\\\\\" === ch ?\n      (buffer = \"\" + buffer + ch + (readChar(reader)), ch = readChar(reader), loop) :\n    \"\\\"\" === ch ?\n      rePattern(buffer) :\n    \"default\" ?\n      (buffer = \"\" + buffer + ch, ch = readChar(reader), loop) :\n      void(0);\n    };\n    return recur;\n  })(\"\", readChar(reader));\n};\nexports.readRegex = readRegex;\n\nvar readParam = function readParam(reader, initch) {\n  var form = readSymbol(reader, initch);\n  return isEqual(form, symbol(\"%\")) ?\n    symbol(\"%1\") :\n    form;\n};\nexports.readParam = readParam;\n\nvar isParam = function isParam(form) {\n  return (isSymbol(form)) && (\"%\" === first(name(form)));\n};\nexports.isParam = isParam;\n\nvar lambdaParamsHash = function lambdaParamsHash(form) {\n  return isParam(form) ?\n    dictionary(form, form) :\n  (isDictionary(form)) || (isVector(form)) || (isList(form)) ?\n    conj.apply(conj, map(lambdaParamsHash, vec(form))) :\n  \"else\" ?\n    {} :\n    void(0);\n};\nexports.lambdaParamsHash = lambdaParamsHash;\n\nvar lambdaParams = function lambdaParams(body) {\n  var names = sort(vals(lambdaParamsHash(body)));\n  var variadic = isEqual(first(names), symbol(\"%&\"));\n  var n = variadic && (count(names) === 1) ?\n    0 :\n    parseInt(rest(name(last(names))));\n  var params = (function loop(names, i) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = i <= n ?\n      (names = conj(names, symbol(\"\" + \"%\" + i)), i = inc(i), loop) :\n      names;\n    };\n    return recur;\n  })([], 1);\n  return variadic ?\n    conj(params, symbol(void(0), \"&\"), symbol(void(0), \"%&\")) :\n    names;\n};\nexports.lambdaParams = lambdaParams;\n\nvar readLambda = function readLambda(reader) {\n  var body = readList(reader);\n  return list(symbol(void(0), \"fn\"), lambdaParams(body), body);\n};\nexports.readLambda = readLambda;\n\nvar readDiscard = function readDiscard(reader, _) {\n  read(reader, true, void(0), true);\n  return reader;\n};\nexports.readDiscard = readDiscard;\n\nvar macros = function macros(c) {\n  return c === \"\\\"\" ?\n    readString :\n  c === \":\" ?\n    readKeyword :\n  c === \";\" ?\n    readComment :\n  c === \"'\" ?\n    wrappingReader(symbol(void(0), \"quote\")) :\n  c === \"@\" ?\n    wrappingReader(symbol(void(0), \"deref\")) :\n  c === \"^\" ?\n    readMeta :\n  c === \"`\" ?\n    wrappingReader(symbol(void(0), \"syntax-quote\")) :\n  c === \"~\" ?\n    readUnquote :\n  c === \"(\" ?\n    readList :\n  c === \")\" ?\n    readUnmatchedDelimiter :\n  c === \"[\" ?\n    readVector :\n  c === \"]\" ?\n    readUnmatchedDelimiter :\n  c === \"{\" ?\n    readMap :\n  c === \"}\" ?\n    readUnmatchedDelimiter :\n  c === \"\\\\\" ?\n    readChar :\n  c === \"%\" ?\n    readParam :\n  c === \"#\" ?\n    readDispatch :\n  \"else\" ?\n    void(0) :\n    void(0);\n};\nexports.macros = macros;\n\nvar dispatchMacros = function dispatchMacros(s) {\n  return s === \"{\" ?\n    readSet :\n  s === \"(\" ?\n    readLambda :\n  s === \"<\" ?\n    throwingReader(\"Unreadable form\") :\n  s === \"\\\"\" ?\n    readRegex :\n  s === \"!\" ?\n    readComment :\n  s === \"_\" ?\n    readDiscard :\n  \"else\" ?\n    void(0) :\n    void(0);\n};\nexports.dispatchMacros = dispatchMacros;\n\nvar readForm = function readForm(reader, ch) {\n  var start = {\n    \"line\": (reader || 0)[\"line\"],\n    \"column\": (reader || 0)[\"column\"]\n  };\n  var readMacro = macros(ch);\n  var form = readMacro ?\n    readMacro(reader, ch) :\n  isNumberLiteral(reader, ch) ?\n    readNumber(reader, ch) :\n  \"else\" ?\n    readSymbol(reader, ch) :\n    void(0);\n  return form === reader ?\n    form :\n  !((isString(form)) || (isNumber(form)) || (isBoolean(form)) || (isNil(form)) || (isKeyword(form))) ?\n    withMeta(form, conj({\n      \"start\": start,\n      \"end\": {\n        \"line\": (reader || 0)[\"line\"],\n        \"column\": (reader || 0)[\"column\"]\n      }\n    }, meta(form))) :\n  \"else\" ?\n    form :\n    void(0);\n};\nexports.readForm = readForm;\n\nvar read = function read(reader, eofIsError, sentinel, isRecursive) {\n  return (function loop() {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (function() {\n      var ch = readChar(reader);\n      var form = isNil(ch) ?\n        eofIsError ?\n          readerError(reader, \"EOF\") :\n          sentinel :\n      isWhitespace(ch) ?\n        reader :\n      isCommentPrefix(ch) ?\n        read(readComment(reader, ch), eofIsError, sentinel, isRecursive) :\n      \"else\" ?\n        readForm(reader, ch) :\n        void(0);\n      return form === reader ?\n        (loop) :\n        form;\n    })();\n    };\n    return recur;\n  })();\n};\nexports.read = read;\n\nvar read_ = function read_(source, uri) {\n  var reader = pushBackReader(source, uri);\n  var eof = gensym();\n  return (function loop(forms, form) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = form === eof ?\n      forms :\n      (forms = conj(forms, form), form = read(reader, false, eof, false), loop);\n    };\n    return recur;\n  })([], read(reader, false, eof, false));\n};\nexports.read_ = read_;\n\nvar readFromString = function readFromString(source, uri) {\n  var reader = pushBackReader(source, uri);\n  return read(reader, true, void(0), false);\n};\nexports.readFromString = readFromString;\n\nvar readUuid = function readUuid(uuid) {\n  return isString(uuid) ?\n    list(symbol(void(0), \"UUID.\"), uuid) :\n    readerError(void(0), \"UUID literal expects a string as its representation.\");\n};\n\nvar readQueue = function readQueue(items) {\n  return isVector(items) ?\n    list(symbol(void(0), \"PersistentQueue.\"), items) :\n    readerError(void(0), \"Queue literal expects a vector for its elements.\");\n};\n\nvar __tagTable__ = dictionary(\"uuid\", readUuid, \"queue\", readQueue);\nexports.__tagTable__ = __tagTable__;\n\nvar maybeReadTaggedType = function maybeReadTaggedType(reader, initch) {\n  var tag = readSymbol(reader, initch);\n  var pfn = __tagTable__[name(tag)];\n  return pfn ?\n    pfn(read(reader, true, void(0), false)) :\n    readerError(reader, \"\" + \"Could not find tag parser for \" + (name(tag)) + \" in \" + (\"\" + (keys(__tagTable__))));\n};\nexports.maybeReadTaggedType = maybeReadTaggedType\n\n//@ sourceURL=/lib/reader.js"
));

require.define("/lib/sequence.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var merge = (require(\"./runtime\")).merge;\nvar inc = (require(\"./runtime\")).inc;\nvar dec = (require(\"./runtime\")).dec;\nvar str = (require(\"./runtime\")).str;\nvar keyValues = (require(\"./runtime\")).keyValues;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isString = (require(\"./runtime\")).isString;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isFn = (require(\"./runtime\")).isFn;\nvar isVector = (require(\"./runtime\")).isVector;\nvar isNil = (require(\"./runtime\")).isNil;;\n\nvar List = function List(head, tail) {\n  this.head = head;\n  this.tail = tail || (list());\n  this.length = inc(count(this.tail));\n  return this;\n};\n\nList.prototype.length = 0;\n\nList.type = \"wisp.list\";\n\nList.prototype.type = List.type;\n\nList.prototype.tail = Object.create(List.prototype);\n\nList.prototype.toString = function() {\n  return (function loop(result, list) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(list) ?\n      \"\" + \"(\" + (result.substr(1)) + \")\" :\n      (result = \"\" + result + \" \" + (isVector(first(list)) ?\n        \"\" + \"[\" + (first(list).join(\" \")) + \"]\" :\n      isNil(first(list)) ?\n        \"nil\" :\n      isString(first(list)) ?\n        JSON.stringify(first(list)) :\n      isNumber(first(list)) ?\n        JSON.stringify(first(list)) :\n        first(list)), list = rest(list), loop);\n    };\n    return recur;\n  })(\"\", this);\n};\n\nvar lazySeqValue = function lazySeqValue(lazySeq) {\n  return !(lazySeq.realized) ?\n    (lazySeq.realized = true) && (lazySeq.x = lazySeq.x()) :\n    lazySeq.x;\n};\n\nvar LazySeq = function LazySeq(realized, x) {\n  this.realized = realized || false;\n  this.x = x;\n  return this;\n};\n\nLazySeq.type = \"wisp.lazy.seq\";\n\nLazySeq.prototype.type = LazySeq.type;\n\nvar lazySeq = function lazySeq(realized, body) {\n  return new LazySeq(realized, body);\n};\nexports.lazySeq = lazySeq;\n\nvar isLazySeq = function isLazySeq(value) {\n  return value && (LazySeq.type === value.type);\n};\nexports.isLazySeq = isLazySeq;\n\n;\n\nvar isList = function isList(value) {\n  return value && (List.type === value.type);\n};\nexports.isList = isList;\n\nvar list = function list() {\n  return arguments.length === 0 ?\n    Object.create(List.prototype) :\n    Array.prototype.slice.call(arguments).reduceRight(function(tail, head) {\n      return cons(head, tail);\n    }, list());\n};\nexports.list = list;\n\nvar cons = function cons(head, tail) {\n  return new List(head, tail);\n};\nexports.cons = cons;\n\nvar reverseList = function reverseList(sequence) {\n  return (function loop(items, source) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(source) ?\n      list.apply(list, items) :\n      (items = [first(source)].concat(items), source = rest(source), loop);\n    };\n    return recur;\n  })([], sequence);\n};\n\nvar isSequential = function isSequential(x) {\n  return (isList(x)) || (isVector(x)) || (isLazySeq(x)) || (isDictionary(x)) || (isString(x));\n};\nexports.isSequential = isSequential;\n\nvar reverse = function reverse(sequence) {\n  return isList(sequence) ?\n    reverseList(sequence) :\n  isVector(sequence) ?\n    sequence.reverse() :\n  isNil(sequence) ?\n    list() :\n  \"else\" ?\n    reverse(seq(sequence)) :\n    void(0);\n};\nexports.reverse = reverse;\n\nvar map = function map(f, sequence) {\n  return isVector(sequence) ?\n    sequence.map(f) :\n  isList(sequence) ?\n    mapList(f, sequence) :\n  isNil(sequence) ?\n    list() :\n  \"else\" ?\n    map(f, seq(sequence)) :\n    void(0);\n};\nexports.map = map;\n\nvar mapList = function mapList(f, sequence) {\n  return (function loop(result, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      reverse(result) :\n      (result = cons(f(first(items)), result), items = rest(items), loop);\n    };\n    return recur;\n  })(list(), sequence);\n};\n\nvar filter = function filter(isF, sequence) {\n  return isVector(sequence) ?\n    sequence.filter(isF) :\n  isList(sequence) ?\n    filterList(isF, sequence) :\n  isNil(sequence) ?\n    list() :\n  \"else\" ?\n    filter(isF, seq(sequence)) :\n    void(0);\n};\nexports.filter = filter;\n\nvar filterList = function filterList(isF, sequence) {\n  return (function loop(result, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      reverse(result) :\n      (result = isF(first(items)) ?\n        cons(first(items), result) :\n        result, items = rest(items), loop);\n    };\n    return recur;\n  })(list(), sequence);\n};\n\nvar reduce = function reduce(f) {\n  var params = Array.prototype.slice.call(arguments, 1);\n  return (function() {\n    var hasInitial = count(params) >= 2;\n    var initial = hasInitial ?\n      first(params) :\n      void(0);\n    var sequence = hasInitial ?\n      second(params) :\n      first(params);\n    return isNil(sequence) ?\n      initial :\n    isVector(sequence) ?\n      hasInitial ?\n        sequence.reduce(f, initial) :\n        sequence.reduce(f) :\n    isList(sequence) ?\n      hasInitial ?\n        reduceList(f, initial, sequence) :\n        reduceList(f, first(sequence), rest(sequence)) :\n    \"else\" ?\n      reduce(f, initial, seq(sequence)) :\n      void(0);\n  })();\n};\nexports.reduce = reduce;\n\nvar reduceList = function reduceList(f, initial, sequence) {\n  return (function loop(result, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      result :\n      (result = f(result, first(items)), items = rest(items), loop);\n    };\n    return recur;\n  })(initial, sequence);\n};\n\nvar count = function count(sequence) {\n  return isNil(sequence) ?\n    0 :\n    (seq(sequence)).length;\n};\nexports.count = count;\n\nvar isEmpty = function isEmpty(sequence) {\n  return count(sequence) === 0;\n};\nexports.isEmpty = isEmpty;\n\nvar first = function first(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  isList(sequence) ?\n    sequence.head :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence[0] :\n  isLazySeq(sequence) ?\n    first(lazySeqValue(sequence)) :\n  \"else\" ?\n    first(seq(sequence)) :\n    void(0);\n};\nexports.first = first;\n\nvar second = function second(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  isList(sequence) ?\n    first(rest(sequence)) :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence[1] :\n  isLazySeq(sequence) ?\n    second(lazySeqValue(sequence)) :\n  \"else\" ?\n    first(rest(seq(sequence))) :\n    void(0);\n};\nexports.second = second;\n\nvar third = function third(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  isList(sequence) ?\n    first(rest(rest(sequence))) :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence[2] :\n  isLazySeq(sequence) ?\n    third(lazySeqValue(sequence)) :\n  \"else\" ?\n    second(rest(seq(sequence))) :\n    void(0);\n};\nexports.third = third;\n\nvar rest = function rest(sequence) {\n  return isNil(sequence) ?\n    list() :\n  isList(sequence) ?\n    sequence.tail :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence.slice(1) :\n  isLazySeq(sequence) ?\n    rest(lazySeqValue(sequence)) :\n  \"else\" ?\n    rest(seq(sequence)) :\n    void(0);\n};\nexports.rest = rest;\n\nvar lastOfList = function lastOfList(list) {\n  return (function loop(item, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      item :\n      (item = first(items), items = rest(items), loop);\n    };\n    return recur;\n  })(first(list), rest(list));\n};\n\nvar last = function last(sequence) {\n  return (isVector(sequence)) || (isString(sequence)) ?\n    sequence[dec(count(sequence))] :\n  isList(sequence) ?\n    lastOfList(sequence) :\n  isNil(sequence) ?\n    void(0) :\n  isLazySeq(sequence) ?\n    last(lazySeqValue(sequence)) :\n  \"else\" ?\n    last(seq(sequence)) :\n    void(0);\n};\nexports.last = last;\n\nvar butlast = function butlast(sequence) {\n  var items = isNil(sequence) ?\n    void(0) :\n  isString(sequence) ?\n    subs(sequence, 0, dec(count(sequence))) :\n  isVector(sequence) ?\n    sequence.slice(0, dec(count(sequence))) :\n  isList(sequence) ?\n    list.apply(list, butlast(vec(sequence))) :\n  isLazySeq(sequence) ?\n    butlast(lazySeqValue(sequence)) :\n  \"else\" ?\n    butlast(seq(sequence)) :\n    void(0);\n  return !((isNil(items)) || (isEmpty(items))) ?\n    items :\n    void(0);\n};\nexports.butlast = butlast;\n\nvar take = function take(n, sequence) {\n  return isNil(sequence) ?\n    list() :\n  isVector(sequence) ?\n    takeFromVector(n, sequence) :\n  isList(sequence) ?\n    takeFromList(n, sequence) :\n  isLazySeq(sequence) ?\n    take(n, lazySeqValue(sequence)) :\n  \"else\" ?\n    take(n, seq(sequence)) :\n    void(0);\n};\nexports.take = take;\n\nvar takeVectorWhile = function takeVectorWhile(predicate, vector) {\n  return (function loop(result, tail, head) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (!(isEmpty(tail))) && (predicate(head)) ?\n      (result = conj(result, head), tail = rest(tail), head = first(tail), loop) :\n      result;\n    };\n    return recur;\n  })([], vector, first(vector));\n};\n\nvar takeListWhile = function takeListWhile(predicate, items) {\n  return (function loop(result, tail, head) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (!(isEmpty(tail))) && (isPredicate(head)) ?\n      (result = conj(result, head), tail = rest(tail), head = first(tail), loop) :\n      list.apply(list, result);\n    };\n    return recur;\n  })([], items, first(items));\n};\n\nvar takeWhile = function takeWhile(predicate, sequence) {\n  return isNil(sequence) ?\n    list() :\n  isVector(sequence) ?\n    takeVectorWhile(predicate, sequence) :\n  isList(sequence) ?\n    takeVectorWhile(predicate, sequence) :\n  \"else\" ?\n    takeWhile(predicate, lazySeqValue(sequence)) :\n    void(0);\n};\nexports.takeWhile = takeWhile;\n\nvar takeFromVector = function takeFromVector(n, vector) {\n  return vector.slice(0, n);\n};\n\nvar takeFromList = function takeFromList(n, sequence) {\n  return (function loop(taken, items, n) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (n === 0) || (isEmpty(items)) ?\n      reverse(taken) :\n      (taken = cons(first(items), taken), items = rest(items), n = dec(n), loop);\n    };\n    return recur;\n  })(list(), sequence, n);\n};\n\nvar dropFromList = function dropFromList(n, sequence) {\n  return (function loop(left, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (left < 1) || (isEmpty(items)) ?\n      items :\n      (left = dec(left), items = rest(items), loop);\n    };\n    return recur;\n  })(n, sequence);\n};\n\nvar drop = function drop(n, sequence) {\n  return n <= 0 ?\n    sequence :\n  isString(sequence) ?\n    sequence.substr(n) :\n  isVector(sequence) ?\n    sequence.slice(n) :\n  isList(sequence) ?\n    dropFromList(n, sequence) :\n  isNil(sequence) ?\n    list() :\n  isLazySeq(sequence) ?\n    drop(n, lazySeqValue(sequence)) :\n  \"else\" ?\n    drop(n, seq(sequence)) :\n    void(0);\n};\nexports.drop = drop;\n\nvar conjList = function conjList(sequence, items) {\n  return reduce(function(result, item) {\n    return cons(item, result);\n  }, sequence, items);\n};\n\nvar conj = function conj(sequence) {\n  var items = Array.prototype.slice.call(arguments, 1);\n  return isVector(sequence) ?\n    sequence.concat(items) :\n  isString(sequence) ?\n    \"\" + sequence + (str.apply(str, items)) :\n  isNil(sequence) ?\n    list.apply(list, reverse(items)) :\n  (isList(sequence)) || (isLazySeq()) ?\n    conjList(sequence, items) :\n  isDictionary(sequence) ?\n    merge(sequence, merge.apply(merge, items)) :\n  \"else\" ?\n    (function() { throw TypeError(\"\" + \"Type can't be conjoined \" + sequence); })() :\n    void(0);\n};\nexports.conj = conj;\n\nvar concat = function concat() {\n  var sequences = Array.prototype.slice.call(arguments, 0);\n  return reverse(reduce(function(result, sequence) {\n    return reduce(function(result, item) {\n      return cons(item, result);\n    }, result, seq(sequence));\n  }, list(), sequences));\n};\nexports.concat = concat;\n\nvar seq = function seq(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  (isVector(sequence)) || (isList(sequence)) || (isLazySeq(sequence)) ?\n    sequence :\n  isString(sequence) ?\n    Array.prototype.slice.call(sequence) :\n  isDictionary(sequence) ?\n    keyValues(sequence) :\n  \"default\" ?\n    (function() { throw TypeError(\"\" + \"Can not seq \" + sequence); })() :\n    void(0);\n};\nexports.seq = seq;\n\nvar isSeq = function isSeq(sequence) {\n  return (isList(sequence)) || (isLazySeq(sequence));\n};\nexports.isSeq = isSeq;\n\nvar listToVector = function listToVector(source) {\n  return (function loop(result, list) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(list) ?\n      result :\n      (result = (function() {\n        result.push(first(list));\n        return result;\n      })(), list = rest(list), loop);\n    };\n    return recur;\n  })([], source);\n};\n\nvar vec = function vec(sequence) {\n  return isNil(sequence) ?\n    [] :\n  isVector(sequence) ?\n    sequence :\n  isList(sequence) ?\n    listToVector(sequence) :\n  \"else\" ?\n    vec(seq(sequence)) :\n    void(0);\n};\nexports.vec = vec;\n\nvar sort = function sort(f, items) {\n  var hasComparator = isFn(f);\n  var items = (!(hasComparator)) && (isNil(items)) ?\n    f :\n    items;\n  var compare = hasComparator ?\n    function(a, b) {\n      return f(a, b) ?\n        0 :\n        1;\n    } :\n    void(0);\n  return isNil(items) ?\n    list() :\n  isVector(items) ?\n    items.sort(compare) :\n  isList(items) ?\n    list.apply(list, vec(items).sort(compare)) :\n  isDictionary(items) ?\n    seq(items).sort(compare) :\n  \"else\" ?\n    sort(f, seq(items)) :\n    void(0);\n};\nexports.sort = sort\n\n//@ sourceURL=/lib/sequence.js"
));

require.define("/lib/runtime.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var identity = function identity(x) {\n  return x;\n};\nexports.identity = identity;\n\nvar isOdd = function isOdd(n) {\n  return n % 2 === 1;\n};\nexports.isOdd = isOdd;\n\nvar isEven = function isEven(n) {\n  return n % 2 === 0;\n};\nexports.isEven = isEven;\n\nvar isDictionary = function isDictionary(form) {\n  return (isObject(form)) && (isObject(Object.getPrototypeOf(form))) && (isNil(Object.getPrototypeOf(Object.getPrototypeOf(form))));\n};\nexports.isDictionary = isDictionary;\n\nvar dictionary = function dictionary() {\n  return (function loop(keyValues, result) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = keyValues.length ?\n      (function() {\n        result[keyValues[0]] = keyValues[1];\n        return (keyValues = keyValues.slice(2), result = result, loop);\n      })() :\n      result;\n    };\n    return recur;\n  })(Array.prototype.slice.call(arguments), {});\n};\nexports.dictionary = dictionary;\n\nvar keys = function keys(dictionary) {\n  return Object.keys(dictionary);\n};\nexports.keys = keys;\n\nvar vals = function vals(dictionary) {\n  return keys(dictionary).map(function(key) {\n    return dictionary[key];\n  });\n};\nexports.vals = vals;\n\nvar keyValues = function keyValues(dictionary) {\n  return keys(dictionary).map(function(key) {\n    return [key, dictionary[key]];\n  });\n};\nexports.keyValues = keyValues;\n\nvar merge = function merge() {\n  return Object.create(Object.prototype, Array.prototype.slice.call(arguments).reduce(function(descriptor, dictionary) {\n    isObject(dictionary) ?\n      Object.keys(dictionary).forEach(function(key) {\n        return descriptor[key] = Object.getOwnPropertyDescriptor(dictionary, key);\n      }) :\n      void(0);\n    return descriptor;\n  }, Object.create(Object.prototype)));\n};\nexports.merge = merge;\n\nvar isContainsVector = function isContainsVector(vector, element) {\n  return vector.indexOf(element) >= 0;\n};\nexports.isContainsVector = isContainsVector;\n\nvar mapDictionary = function mapDictionary(source, f) {\n  return Object.keys(source).reduce(function(target, key) {\n    target[key] = f(source[key]);\n    return target;\n  }, {});\n};\nexports.mapDictionary = mapDictionary;\n\nvar toString = Object.prototype.toString;\nexports.toString = toString;\n\nvar isFn = typeof(/./) === \"function\" ?\n  function isFn(x) {\n    return toString.call(x) === \"[object Function]\";\n  } :\n  function isFn(x) {\n    return typeof(x) === \"function\";\n  };\nexports.isFn = isFn;\n\nvar isString = function isString(x) {\n  return (typeof(x) === \"string\") || (toString.call(x) === \"[object String]\");\n};\nexports.isString = isString;\n\nvar isNumber = function isNumber(x) {\n  return (typeof(x) === \"number\") || (toString.call(x) === \"[object Number]\");\n};\nexports.isNumber = isNumber;\n\nvar isVector = isFn(Array.isArray) ?\n  Array.isArray :\n  function isVector(x) {\n    return toString.call(x) === \"[object Array]\";\n  };\nexports.isVector = isVector;\n\nvar isDate = function isDate(x) {\n  return toString.call(x) === \"[object Date]\";\n};\nexports.isDate = isDate;\n\nvar isBoolean = function isBoolean(x) {\n  return (x === true) || (x === false) || (toString.call(x) === \"[object Boolean]\");\n};\nexports.isBoolean = isBoolean;\n\nvar isRePattern = function isRePattern(x) {\n  return toString.call(x) === \"[object RegExp]\";\n};\nexports.isRePattern = isRePattern;\n\nvar isObject = function isObject(x) {\n  return x && (typeof(x) === \"object\");\n};\nexports.isObject = isObject;\n\nvar isNil = function isNil(x) {\n  return (x === void(0)) || (x === null);\n};\nexports.isNil = isNil;\n\nvar isTrue = function isTrue(x) {\n  return x === true;\n};\nexports.isTrue = isTrue;\n\nvar isFalse = function isFalse(x) {\n  return x === true;\n};\nexports.isFalse = isFalse;\n\nvar reFind = function reFind(re, s) {\n  var matches = re.exec(s);\n  return !(isNil(matches)) ?\n    matches.length === 1 ?\n      matches[0] :\n      matches :\n    void(0);\n};\nexports.reFind = reFind;\n\nvar reMatches = function reMatches(pattern, source) {\n  var matches = pattern.exec(source);\n  return (!(isNil(matches))) && (matches[0] === source) ?\n    matches.length === 1 ?\n      matches[0] :\n      matches :\n    void(0);\n};\nexports.reMatches = reMatches;\n\nvar rePattern = function rePattern(s) {\n  var match = reFind(/^(?:\\(\\?([idmsux]*)\\))?(.*)/, s);\n  return new RegExp(match[2], match[1]);\n};\nexports.rePattern = rePattern;\n\nvar inc = function inc(x) {\n  return x + 1;\n};\nexports.inc = inc;\n\nvar dec = function dec(x) {\n  return x - 1;\n};\nexports.dec = dec;\n\nvar str = function str() {\n  return String.prototype.concat.apply(\"\", arguments);\n};\nexports.str = str;\n\nvar char = function char(code) {\n  return String.fromCharCode(code);\n};\nexports.char = char;\n\nvar int = function int(x) {\n  return isNumber(x) ?\n    x >= 0 ?\n      Math.floor(x) :\n      Math.floor(x) :\n    x.charCodeAt(0);\n};\nexports.int = int;\n\nvar subs = function subs(string, start, end) {\n  return string.substring(start, end);\n};\nexports.subs = subs;\n\nvar isPatternEqual = function isPatternEqual(x, y) {\n  return (isRePattern(x)) && (isRePattern(y)) && (x.source === y.source) && (x.global === y.global) && (x.multiline === y.multiline) && (x.ignoreCase === y.ignoreCase);\n};\n\nvar isDateEqual = function isDateEqual(x, y) {\n  return (isDate(x)) && (isDate(y)) && (Number(x) === Number(y));\n};\n\nvar isDictionaryEqual = function isDictionaryEqual(x, y) {\n  return (isObject(x)) && (isObject(y)) && ((function() {\n    var xKeys = keys(x);\n    var yKeys = keys(y);\n    var xCount = xKeys.length;\n    var yCount = yKeys.length;\n    return (xCount === yCount) && ((function loop(index, count, keys) {\n      var recur = loop;\n      while (recur === loop) {\n        recur = index < count ?\n        isEquivalent(x[keys[index]], y[keys[index]]) ?\n          (index = inc(index), count = count, keys = keys, loop) :\n          false :\n        true;\n      };\n      return recur;\n    })(0, xCount, xKeys));\n  })());\n};\n\nvar isVectorEqual = function isVectorEqual(x, y) {\n  return (isVector(x)) && (isVector(y)) && (x.length === y.length) && ((function loop(xs, ys, index, count) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = index < count ?\n      isEquivalent(xs[index], ys[index]) ?\n        (xs = xs, ys = ys, index = inc(index), count = count, loop) :\n        false :\n      true;\n    };\n    return recur;\n  })(x, y, 0, x.length));\n};\n\nvar isEquivalent = function isEquivalent(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return (x === y) || (isNil(x) ?\n        isNil(y) :\n      isNil(y) ?\n        isNil(x) :\n      isString(x) ?\n        false :\n      isNumber(x) ?\n        false :\n      isFn(x) ?\n        false :\n      isBoolean(x) ?\n        false :\n      isDate(x) ?\n        isDateEqual(x, y) :\n      isVector(x) ?\n        isVectorEqual(x, y, [], []) :\n      isRePattern(x) ?\n        isPatternEqual(x, y) :\n      \"else\" ?\n        isDictionaryEqual(x, y) :\n        void(0));\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (isEquivalent(previous, current)) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\n\nvar isEqual = isEquivalent;\nexports.isEqual = isEqual;\n\nvar isStrictEqual = function isStrictEqual(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x === y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous === current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.isStrictEqual = isStrictEqual;\n\nvar greaterThan = function greaterThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x > y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous > current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.greaterThan = greaterThan;\n\nvar notLessThan = function notLessThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x >= y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous >= current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.notLessThan = notLessThan;\n\nvar lessThan = function lessThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x < y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous < current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.lessThan = lessThan;\n\nvar notGreaterThan = function notGreaterThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x <= y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous <= current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.notGreaterThan = notGreaterThan;\n\nvar sum = function sum(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return 0;\n    case 1:\n      return a;\n    case 2:\n      return a + b;\n    case 3:\n      return a + b + c;\n    case 4:\n      return a + b + c + d;\n    case 5:\n      return a + b + c + d + e;\n    case 6:\n      return a + b + c + d + e + f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value + (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a + b + c + d + e + f, 0, more.length);\n  };\n  return void(0);\n};\nexports.sum = sum;\n\nvar subtract = function subtract(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return (function() { throw TypeError(\"Wrong number of args passed to: -\"); })();\n    case 1:\n      return 0 - a;\n    case 2:\n      return a - b;\n    case 3:\n      return a - b - c;\n    case 4:\n      return a - b - c - d;\n    case 5:\n      return a - b - c - d - e;\n    case 6:\n      return a - b - c - d - e - f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value - (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a - b - c - d - e - f, 0, more.length);\n  };\n  return void(0);\n};\nexports.subtract = subtract;\n\nvar divide = function divide(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return (function() { throw TypeError(\"Wrong number of args passed to: /\"); })();\n    case 1:\n      return 1 / a;\n    case 2:\n      return a / b;\n    case 3:\n      return a / b / c;\n    case 4:\n      return a / b / c / d;\n    case 5:\n      return a / b / c / d / e;\n    case 6:\n      return a / b / c / d / e / f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value / (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a / b / c / d / e / f, 0, more.length);\n  };\n  return void(0);\n};\nexports.divide = divide;\n\nvar multiply = function multiply(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return 1;\n    case 1:\n      return a;\n    case 2:\n      return a * b;\n    case 3:\n      return a * b * c;\n    case 4:\n      return a * b * c * d;\n    case 5:\n      return a * b * c * d * e;\n    case 6:\n      return a * b * c * d * e * f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value * (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a * b * c * d * e * f, 0, more.length);\n  };\n  return void(0);\n};\nexports.multiply = multiply;\n\nvar and = function and(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return true;\n    case 1:\n      return a;\n    case 2:\n      return a && b;\n    case 3:\n      return a && b && c;\n    case 4:\n      return a && b && c && d;\n    case 5:\n      return a && b && c && d && e;\n    case 6:\n      return a && b && c && d && e && f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value && (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a && b && c && d && e && f, 0, more.length);\n  };\n  return void(0);\n};\nexports.and = and;\n\nvar or = function or(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return void(0);\n    case 1:\n      return a;\n    case 2:\n      return a || b;\n    case 3:\n      return a || b || c;\n    case 4:\n      return a || b || c || d;\n    case 5:\n      return a || b || c || d || e;\n    case 6:\n      return a || b || c || d || e || f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value || (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a || b || c || d || e || f, 0, more.length);\n  };\n  return void(0);\n};\nexports.or = or\n\n//@ sourceURL=/lib/runtime.js"
));

require.define("/lib/ast.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var vec = (require(\"./sequence\")).vec;\nvar map = (require(\"./sequence\")).map;\nvar last = (require(\"./sequence\")).last;\nvar count = (require(\"./sequence\")).count;\nvar second = (require(\"./sequence\")).second;\nvar first = (require(\"./sequence\")).first;\nvar isSequential = (require(\"./sequence\")).isSequential;\nvar isList = (require(\"./sequence\")).isList;;\n\nvar join = (require(\"./string\")).join;\nvar split = (require(\"./string\")).split;;\n\nvar isEqual = (require(\"./runtime\")).isEqual;\nvar subs = (require(\"./runtime\")).subs;\nvar inc = (require(\"./runtime\")).inc;\nvar str = (require(\"./runtime\")).str;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isRePattern = (require(\"./runtime\")).isRePattern;\nvar isDate = (require(\"./runtime\")).isDate;\nvar isObject = (require(\"./runtime\")).isObject;\nvar isBoolean = (require(\"./runtime\")).isBoolean;\nvar isString = (require(\"./runtime\")).isString;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isVector = (require(\"./runtime\")).isVector;\nvar isNil = (require(\"./runtime\")).isNil;;\n\nvar withMeta = function withMeta(value, metadata) {\n  Object.defineProperty(value, \"metadata\", {\n    \"value\": metadata,\n    \"configurable\": true\n  });\n  return value;\n};\nexports.withMeta = withMeta;\n\nvar meta = function meta(value) {\n  return isObject(value) ?\n    value.metadata :\n    void(0);\n};\nexports.meta = meta;\n\nvar __nsSeparator__ = \"â\";\nexports.__nsSeparator__ = __nsSeparator__;\n\nvar Symbol = function Symbol(namespace, name) {\n  this.namespace = namespace;\n  this.name = name;\n  return this;\n};\n\nSymbol.type = \"wisp.symbol\";\n\nSymbol.prototype.type = Symbol.type;\n\nSymbol.prototype.toString = function() {\n  var ns = namespace(this);\n  return ns ?\n    \"\" + ns + \"/\" + (name(this)) :\n    \"\" + (name(this));\n};\n\nvar symbol = function symbol(ns, id) {\n  return isSymbol(ns) ?\n    ns :\n  isKeyword(ns) ?\n    new Symbol(namespace(ns), name(ns)) :\n  isNil(id) ?\n    new Symbol(void(0), ns) :\n  \"else\" ?\n    new Symbol(ns, id) :\n    void(0);\n};\nexports.symbol = symbol;\n\nvar isSymbol = function isSymbol(x) {\n  return x && (Symbol.type === x.type);\n};\nexports.isSymbol = isSymbol;\n\nvar isKeyword = function isKeyword(x) {\n  return (isString(x)) && (count(x) > 1) && (first(x) === \"ê\");\n};\nexports.isKeyword = isKeyword;\n\nvar keyword = function keyword(ns, id) {\n  return isKeyword(ns) ?\n    ns :\n  isSymbol(ns) ?\n    \"\" + \"ê\" + (name(ns)) :\n  isNil(id) ?\n    \"\" + \"ê\" + ns :\n  isNil(ns) ?\n    \"\" + \"ê\" + id :\n  \"else\" ?\n    \"\" + \"ê\" + ns + __nsSeparator__ + id :\n    void(0);\n};\nexports.keyword = keyword;\n\nvar keywordName = function keywordName(value) {\n  return last(split(subs(value, 1), __nsSeparator__));\n};\n\nvar name = function name(value) {\n  return isSymbol(value) ?\n    value.name :\n  isKeyword(value) ?\n    keywordName(value) :\n  isString(value) ?\n    value :\n  \"else\" ?\n    (function() { throw new TypeError(\"\" + \"Doesn't support name: \" + value); })() :\n    void(0);\n};\nexports.name = name;\n\nvar keywordNamespace = function keywordNamespace(x) {\n  var parts = split(subs(x, 1), __nsSeparator__);\n  return count(parts) > 1 ?\n    parts[0] :\n    void(0);\n};\n\nvar namespace = function namespace(x) {\n  return isSymbol(x) ?\n    x.namespace :\n  isKeyword(x) ?\n    keywordNamespace(x) :\n  \"else\" ?\n    (function() { throw new TypeError(\"\" + \"Doesn't supports namespace: \" + x); })() :\n    void(0);\n};\nexports.namespace = namespace;\n\nvar gensym = function gensym(prefix) {\n  return symbol(\"\" + (isNil(prefix) ?\n    \"G__\" :\n    prefix) + (gensym.base = gensym.base + 1));\n};\nexports.gensym = gensym;\n\ngensym.base = 0;\n\nvar isUnquote = function isUnquote(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"unquote\")));\n};\nexports.isUnquote = isUnquote;\n\nvar isUnquoteSplicing = function isUnquoteSplicing(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"unquote-splicing\")));\n};\nexports.isUnquoteSplicing = isUnquoteSplicing;\n\nvar isQuote = function isQuote(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"quote\")));\n};\nexports.isQuote = isQuote;\n\nvar isSyntaxQuote = function isSyntaxQuote(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"syntax-quote\")));\n};\nexports.isSyntaxQuote = isSyntaxQuote;\n\nvar normalize = function normalize(n, len) {\n  return (function loop(ns) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = count(ns) < len ?\n      (ns = \"\" + \"0\" + ns, loop) :\n      ns;\n    };\n    return recur;\n  })(\"\" + n);\n};\n\nvar quoteString = function quoteString(s) {\n  s = join(\"\\\\\\\"\", split(s, \"\\\"\"));\n  s = join(\"\\\\\\\\\", split(s, \"\\\\\"));\n  s = join(\"\\\\b\", split(s, \"\b\"));\n  s = join(\"\\\\f\", split(s, \"\f\"));\n  s = join(\"\\\\n\", split(s, \"\\n\"));\n  s = join(\"\\\\r\", split(s, \"\\r\"));\n  s = join(\"\\\\t\", split(s, \"\\t\"));\n  return \"\" + \"\\\"\" + s + \"\\\"\";\n};\nexports.quoteString = quoteString;\n\nvar prStr = function prStr(x) {\n  return isNil(x) ?\n    \"nil\" :\n  isKeyword(x) ?\n    namespace(x) ?\n      \"\" + \":\" + (namespace(x)) + \"/\" + (name(x)) :\n      \"\" + \":\" + (name(x)) :\n  isString(x) ?\n    quoteString(x) :\n  isDate(x) ?\n    \"\" + \"#inst \\\"\" + (x.getUTCFullYear()) + \"-\" + (normalize(inc(x.getUTCMonth()), 2)) + \"-\" + (normalize(x.getUTCDate(), 2)) + \"T\" + (normalize(x.getUTCHours(), 2)) + \":\" + (normalize(x.getUTCMinutes(), 2)) + \":\" + (normalize(x.getUTCSeconds(), 2)) + \".\" + (normalize(x.getUTCMilliseconds(), 3)) + \"-\" + \"00:00\\\"\" :\n  isVector(x) ?\n    \"\" + \"[\" + (join(\" \", map(prStr, vec(x)))) + \"]\" :\n  isDictionary(x) ?\n    \"\" + \"{\" + (join(\", \", map(function(pair) {\n      return \"\" + (prStr(first(pair))) + \" \" + (prStr(second(pair)));\n    }, x))) + \"}\" :\n  isSequential(x) ?\n    \"\" + \"(\" + (join(\" \", map(prStr, vec(x)))) + \")\" :\n  isRePattern(x) ?\n    \"\" + \"#\\\"\" + (join(\"\\\\/\", split(x.source, \"/\"))) + \"\\\"\" :\n  \"else\" ?\n    \"\" + x :\n    void(0);\n};\nexports.prStr = prStr\n\n//@ sourceURL=/lib/ast.js"
));

require.define("/lib/string.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var isString = (require(\"./runtime\")).isString;\nvar isNil = (require(\"./runtime\")).isNil;\nvar reMatches = (require(\"./runtime\")).reMatches;\nvar subs = (require(\"./runtime\")).subs;\nvar str = (require(\"./runtime\")).str;;\n\nvar isEmpty = (require(\"./sequence\")).isEmpty;\nvar vec = (require(\"./sequence\")).vec;;\n\nvar split = function split(string, pattern, limit) {\n  return string.split(pattern, limit);\n};\nexports.split = split;\n\nvar join = function join(separator, coll) {\n  switch (arguments.length) {\n    case 1:\n      var coll = separator;\n      return str.apply(str, vec(coll));\n    case 2:\n      return vec(coll).join(separator);\n    \n    default:\n      (function() { throw Error(\"Invalid arity\"); })()\n  };\n  return void(0);\n};\nexports.join = join;\n\nvar upperCase = function upperCase(string) {\n  return string.toUpperCase();\n};\nexports.upperCase = upperCase;\n\nvar upperCase = function upperCase(string) {\n  return string.toUpperCase();\n};\nexports.upperCase = upperCase;\n\nvar lowerCase = function lowerCase(string) {\n  return string.toLowerCase();\n};\nexports.lowerCase = lowerCase;\n\nvar capitalize = function capitalize(string) {\n  return count(string) < 2 ?\n    upperCase(string) :\n    \"\" + (upperCase(subs(s, 0, 1))) + (lowerCase(subs(s, 1)));\n};\nexports.capitalize = capitalize;\n\nvar replace = function replace(string, match, replacement) {\n  return string.replace(match, replacement);\n};\nexports.replace = replace;\n\nvar __LEFTSPACES__ = /^\\s\\s*/;\nexports.__LEFTSPACES__ = __LEFTSPACES__;\n\nvar __RIGHTSPACES__ = /\\s\\s*$/;\nexports.__RIGHTSPACES__ = __RIGHTSPACES__;\n\nvar __SPACES__ = /^\\s\\s*$/;\nexports.__SPACES__ = __SPACES__;\n\nvar triml = isNil(\"\".trimLeft) ?\n  function(string) {\n    return string.replace(__LEFTSPACES__, \"\");\n  } :\n  function triml(string) {\n    return string.trimLeft();\n  };\nexports.triml = triml;\n\nvar trimr = isNil(\"\".trimRight) ?\n  function(string) {\n    return string.replace(__RIGHTSPACES__, \"\");\n  } :\n  function trimr(string) {\n    return string.trimRight();\n  };\nexports.trimr = trimr;\n\nvar trim = isNil(\"\".trim) ?\n  function(string) {\n    return string.replace(__LEFTSPACES__).replace(__RIGHTSPACES__);\n  } :\n  function trim(string) {\n    return string.trim();\n  };\nexports.trim = trim;\n\nvar isBlank = function isBlank(string) {\n  return (isNil(string)) || (isEmpty(string)) || (reMatches(__SPACES__, string));\n};\nexports.isBlank = isBlank\n\n//@ sourceURL=/lib/string.js"
));

require.define("/lib/compiler.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var readFromString = (require(\"./reader\")).readFromString;;\n\nvar prStr = (require(\"./ast\")).prStr;\nvar gensym = (require(\"./ast\")).gensym;\nvar name = (require(\"./ast\")).name;\nvar isSyntaxQuote = (require(\"./ast\")).isSyntaxQuote;\nvar isQuote = (require(\"./ast\")).isQuote;\nvar isUnquoteSplicing = (require(\"./ast\")).isUnquoteSplicing;\nvar isUnquote = (require(\"./ast\")).isUnquote;\nvar namespace = (require(\"./ast\")).namespace;\nvar keyword = (require(\"./ast\")).keyword;\nvar isKeyword = (require(\"./ast\")).isKeyword;\nvar symbol = (require(\"./ast\")).symbol;\nvar isSymbol = (require(\"./ast\")).isSymbol;\nvar withMeta = (require(\"./ast\")).withMeta;\nvar meta = (require(\"./ast\")).meta;;\n\nvar concat = (require(\"./sequence\")).concat;\nvar take = (require(\"./sequence\")).take;\nvar filter = (require(\"./sequence\")).filter;\nvar map = (require(\"./sequence\")).map;\nvar last = (require(\"./sequence\")).last;\nvar vec = (require(\"./sequence\")).vec;\nvar reduce = (require(\"./sequence\")).reduce;\nvar reverse = (require(\"./sequence\")).reverse;\nvar conj = (require(\"./sequence\")).conj;\nvar cons = (require(\"./sequence\")).cons;\nvar rest = (require(\"./sequence\")).rest;\nvar third = (require(\"./sequence\")).third;\nvar second = (require(\"./sequence\")).second;\nvar first = (require(\"./sequence\")).first;\nvar list = (require(\"./sequence\")).list;\nvar isList = (require(\"./sequence\")).isList;\nvar count = (require(\"./sequence\")).count;\nvar isEmpty = (require(\"./sequence\")).isEmpty;;\n\nvar isStrictEqual = (require(\"./runtime\")).isStrictEqual;\nvar isEqual = (require(\"./runtime\")).isEqual;\nvar int = (require(\"./runtime\")).int;\nvar char = (require(\"./runtime\")).char;\nvar str = (require(\"./runtime\")).str;\nvar dec = (require(\"./runtime\")).dec;\nvar inc = (require(\"./runtime\")).inc;\nvar isRePattern = (require(\"./runtime\")).isRePattern;\nvar isNil = (require(\"./runtime\")).isNil;\nvar isFalse = (require(\"./runtime\")).isFalse;\nvar isTrue = (require(\"./runtime\")).isTrue;\nvar reFind = (require(\"./runtime\")).reFind;\nvar subs = (require(\"./runtime\")).subs;\nvar isBoolean = (require(\"./runtime\")).isBoolean;\nvar isVector = (require(\"./runtime\")).isVector;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isString = (require(\"./runtime\")).isString;\nvar mapDictionary = (require(\"./runtime\")).mapDictionary;\nvar isContainsVector = (require(\"./runtime\")).isContainsVector;\nvar vals = (require(\"./runtime\")).vals;\nvar keys = (require(\"./runtime\")).keys;\nvar merge = (require(\"./runtime\")).merge;\nvar dictionary = (require(\"./runtime\")).dictionary;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isOdd = (require(\"./runtime\")).isOdd;;\n\nvar replace = (require(\"./string\")).replace;\nvar upperCase = (require(\"./string\")).upperCase;\nvar join = (require(\"./string\")).join;\nvar split = (require(\"./string\")).split;;\n\nvar writeBoolean = (require(\"./backend/javascript/writer\")).writeBoolean;\nvar writeNumber = (require(\"./backend/javascript/writer\")).writeNumber;\nvar writeString = (require(\"./backend/javascript/writer\")).writeString;\nvar writeNumber = (require(\"./backend/javascript/writer\")).writeNumber;\nvar writeComment = (require(\"./backend/javascript/writer\")).writeComment;\nvar writeNil = (require(\"./backend/javascript/writer\")).writeNil;\nvar writeSymbol = (require(\"./backend/javascript/writer\")).writeSymbol;\nvar writeKeyword = (require(\"./backend/javascript/writer\")).writeKeyword;\nvar writeKeywordReference = (require(\"./backend/javascript/writer\")).writeKeywordReference;\nvar writeReference = (require(\"./backend/javascript/writer\")).writeReference;;\n\nvar isSelfEvaluating = function isSelfEvaluating(form) {\n  return (isNumber(form)) || ((isString(form)) && (!(isSymbol(form))) && (!(isKeyword(form)))) || (isBoolean(form)) || (isNil(form)) || (isRePattern(form));\n};\nexports.isSelfEvaluating = isSelfEvaluating;\n\nvar __macros__ = {};\nexports.__macros__ = __macros__;\n\nvar executeMacro = function executeMacro(name, form) {\n  return __macros__[name].apply(__macros__[name], vec(form));\n};\nexports.executeMacro = executeMacro;\n\nvar installMacro = function installMacro(name, macroFn) {\n  return __macros__[name] = macroFn;\n};\nexports.installMacro = installMacro;\n\nvar isMacro = function isMacro(name) {\n  return (isSymbol(name)) && (__macros__[name]) && true;\n};\nexports.isMacro = isMacro;\n\nvar makeMacro = function makeMacro(pattern, body) {\n  var macroFn = concat(list(symbol(void(0), \"fn\"), pattern), body);\n  return eval(\"\" + \"(\" + (compile(macroexpand(macroFn))) + \")\");\n};\nexports.makeMacro = makeMacro;\n\ninstallMacro(symbol(void(0), \"defmacro\"), function(name, signature) {\n  var body = Array.prototype.slice.call(arguments, 2);\n  return installMacro(name, makeMacro(signature, body));\n});\n\nvar __specials__ = {};\nexports.__specials__ = __specials__;\n\nvar installSpecial = function installSpecial(name, f, validator) {\n  return __specials__[name] = function(form) {\n    validator ?\n      validator(form) :\n      void(0);\n    return f(withMeta(rest(form), meta(form)));\n  };\n};\nexports.installSpecial = installSpecial;\n\nvar isSpecial = function isSpecial(name) {\n  return (isSymbol(name)) && (__specials__[name]) && true;\n};\nexports.isSpecial = isSpecial;\n\nvar executeSpecial = function executeSpecial(name, form) {\n  return (__specials__[name])(form);\n};\nexports.executeSpecial = executeSpecial;\n\nvar opt = function opt(argument, fallback) {\n  return (isNil(argument)) || (isEmpty(argument)) ?\n    fallback :\n    first(argument);\n};\nexports.opt = opt;\n\nvar applyForm = function applyForm(fnName, form, isQuoted) {\n  return cons(fnName, isQuoted ?\n    map(function(e) {\n      return list(symbol(void(0), \"quote\"), e);\n    }, form) :\n    form, form);\n};\nexports.applyForm = applyForm;\n\nvar applyUnquotedForm = function applyUnquotedForm(fnName, form) {\n  return cons(fnName, map(function(e) {\n    return isUnquote(e) ?\n      second(e) :\n    (isList(e)) && (isKeyword(first(e))) ?\n      list(symbol(void(0), \"syntax-quote\"), second(e)) :\n      list(symbol(void(0), \"syntax-quote\"), e);\n  }, form));\n};\nexports.applyUnquotedForm = applyUnquotedForm;\n\nvar splitSplices = function splitSplices(form, fnName) {\n  var makeSplice = function makeSplice(form) {\n    return (isSelfEvaluating(form)) || (isSymbol(form)) ?\n      applyUnquotedForm(fnName, list(form)) :\n      applyUnquotedForm(fnName, form);\n  };\n  return (function loop(nodes, slices, acc) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(nodes) ?\n      reverse(isEmpty(acc) ?\n        slices :\n        cons(makeSplice(reverse(acc)), slices)) :\n      (function() {\n        var node = first(nodes);\n        return isUnquoteSplicing(node) ?\n          (nodes = rest(nodes), slices = cons(second(node), isEmpty(acc) ?\n            slices :\n            cons(makeSplice(reverse(acc)), slices)), acc = list(), loop) :\n          (nodes = rest(nodes), slices = slices, acc = cons(node, acc), loop);\n      })();\n    };\n    return recur;\n  })(form, list(), list());\n};\nexports.splitSplices = splitSplices;\n\nvar syntaxQuoteSplit = function syntaxQuoteSplit(appendName, fnName, form) {\n  var slices = splitSplices(form, fnName);\n  var n = count(slices);\n  return n === 0 ?\n    list(fnName) :\n  n === 1 ?\n    first(slices) :\n  \"default\" ?\n    applyForm(appendName, slices) :\n    void(0);\n};\nexports.syntaxQuoteSplit = syntaxQuoteSplit;\n\nvar compileObject = function compileObject(form, isQuoted) {\n  return isKeyword(form) ?\n    writeKeyword(form) :\n  isSymbol(form) ?\n    writeSymbol(form) :\n  isNumber(form) ?\n    writeNumber(form) :\n  isString(form) ?\n    writeString(form) :\n  isBoolean(form) ?\n    writeBoolean(form) :\n  isNil(form) ?\n    writeNil(form) :\n  isRePattern(form) ?\n    compileRePattern(form) :\n  isVector(form) ?\n    compile(applyForm(symbol(void(0), \"vector\"), list.apply(list, form), isQuoted)) :\n  isList(form) ?\n    compile(applyForm(symbol(void(0), \"list\"), form, isQuoted)) :\n  isDictionary(form) ?\n    compileDictionary(isQuoted ?\n      mapDictionary(form, function(x) {\n        return list(symbol(void(0), \"quote\"), x);\n      }) :\n      form) :\n    void(0);\n};\nexports.compileObject = compileObject;\n\nvar compileSyntaxQuotedVector = function compileSyntaxQuotedVector(form) {\n  var concatForm = syntaxQuoteSplit(symbol(void(0), \"concat\"), symbol(void(0), \"vector\"), list.apply(list, form));\n  return compile(count(concatForm) > 1 ?\n    list(symbol(void(0), \"vec\"), concatForm) :\n    concatForm);\n};\nexports.compileSyntaxQuotedVector = compileSyntaxQuotedVector;\n\nvar compileSyntaxQuoted = function compileSyntaxQuoted(form) {\n  return isList(form) ?\n    compile(syntaxQuoteSplit(symbol(void(0), \"concat\"), symbol(void(0), \"list\"), form)) :\n  isVector(form) ?\n    compileSyntaxQuotedVector(form) :\n  \"else\" ?\n    compileObject(form) :\n    void(0);\n};\nexports.compileSyntaxQuoted = compileSyntaxQuoted;\n\nvar compile = function compile(form) {\n  return isSelfEvaluating(form) ?\n    compileObject(form) :\n  isSymbol(form) ?\n    writeReference(form) :\n  isKeyword(form) ?\n    writeKeywordReference(form) :\n  isVector(form) ?\n    compileObject(form) :\n  isDictionary(form) ?\n    compileObject(form) :\n  isList(form) ?\n    (function() {\n      var head = first(form);\n      return isEmpty(form) ?\n        compileObject(form, true) :\n      isQuote(form) ?\n        compileObject(second(form), true) :\n      isSyntaxQuote(form) ?\n        compileSyntaxQuoted(second(form)) :\n      isSpecial(head) ?\n        executeSpecial(head, form) :\n      isKeyword(head) ?\n        compile(list(symbol(void(0), \"get\"), list(symbol(void(0), \"or\"), second(form), 0), head)) :\n      \"else\" ?\n        (function() {\n          return !((isSymbol(head)) || (isList(head))) ?\n            (function() { throw compilerError(form, \"\" + \"operator is not a procedure: \" + head); })() :\n            compileInvoke(form);\n        })() :\n        void(0);\n    })() :\n    void(0);\n};\nexports.compile = compile;\n\nvar compile_ = function compile_(forms) {\n  return reduce(function(result, form) {\n    return \"\" + result + (isEmpty(result) ?\n      \"\" :\n      \";\\n\\n\") + (compile(isList(form) ?\n      withMeta(macroexpand(form), conj({\n        \"top\": true\n      }, meta(form))) :\n      form));\n  }, \"\", forms);\n};\nexports.compile_ = compile_;\n\nvar compileProgram = function compileProgram(forms) {\n  return reduce(function(result, form) {\n    return \"\" + result + (isEmpty(result) ?\n      \"\" :\n      \";\\n\\n\") + (compile(isList(form) ?\n      withMeta(macroexpand(form), conj({\n        \"top\": true\n      }, meta(form))) :\n      form));\n  }, \"\", forms);\n};\nexports.compileProgram = compileProgram;\n\nvar macroexpand1 = function macroexpand1(form) {\n  return isList(form) ?\n    (function() {\n      var op = first(form);\n      var id = isSymbol(op) ?\n        name(op) :\n        void(0);\n      return isSpecial(op) ?\n        form :\n      isMacro(op) ?\n        executeMacro(op, rest(form)) :\n      (isSymbol(op)) && (!(id === \".\")) ?\n        first(id) === \".\" ?\n          count(form) < 2 ?\n            (function() { throw Error(\"Malformed member expression, expecting (.member target ...)\"); })() :\n            cons(symbol(void(0), \".\"), cons(second(form), cons(symbol(subs(id, 1)), rest(rest(form))))) :\n        last(id) === \".\" ?\n          cons(symbol(void(0), \"new\"), cons(symbol(subs(id, 0, dec(count(id)))), rest(form))) :\n          form :\n      \"else\" ?\n        form :\n        void(0);\n    })() :\n    form;\n};\nexports.macroexpand1 = macroexpand1;\n\nvar macroexpand = function macroexpand(form) {\n  return (function loop(original, expanded) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = original === expanded ?\n      original :\n      (original = expanded, expanded = macroexpand1(expanded), loop);\n    };\n    return recur;\n  })(form, macroexpand1(form));\n};\nexports.macroexpand = macroexpand;\n\nvar compileTemplate = function compileTemplate(form) {\n  var indentPattern = /\\n *$/;\n  var lineBreakPatter = RegExp(\"\\n\", \"g\");\n  var getIndentation = function(code) {\n    return (reFind(indentPattern, code)) || \"\\n\";\n  };\n  return (function loop(code, parts, values) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = count(parts) > 1 ?\n      (code = \"\" + code + (first(parts)) + (replace(\"\" + \"\" + (first(values)), lineBreakPatter, getIndentation(first(parts)))), parts = rest(parts), values = rest(values), loop) :\n      \"\" + code + (first(parts));\n    };\n    return recur;\n  })(\"\", split(first(form), \"~{}\"), rest(form));\n};\nexports.compileTemplate = compileTemplate;\n\nvar compileDef = function compileDef(form) {\n  var id = first(form);\n  var isExport = ((((meta(form)) || {}) || 0)[\"top\"]) && (!((((meta(id)) || {}) || 0)[\"private\"]));\n  var attribute = symbol(namespace(id), \"\" + \"-\" + (name(id)));\n  return isExport ?\n    compileTemplate(list(\"var ~{};\\n~{}\", compile(cons(symbol(void(0), \"set!\"), form)), compile(list(symbol(void(0), \"set!\"), list(symbol(void(0), \".\"), symbol(void(0), \"exports\"), attribute), id)))) :\n    compileTemplate(list(\"var ~{}\", compile(cons(symbol(void(0), \"set!\"), form))));\n};\nexports.compileDef = compileDef;\n\nvar compileIfElse = function compileIfElse(form) {\n  var condition = macroexpand(first(form));\n  var thenExpression = macroexpand(second(form));\n  var elseExpression = macroexpand(third(form));\n  return compileTemplate(list((isList(elseExpression)) && (isEqual(first(elseExpression), symbol(void(0), \"if\"))) ?\n    \"~{} ?\\n  ~{} :\\n~{}\" :\n    \"~{} ?\\n  ~{} :\\n  ~{}\", compile(condition), compile(thenExpression), compile(elseExpression)));\n};\nexports.compileIfElse = compileIfElse;\n\nvar compileDictionary = function compileDictionary(form) {\n  var body = (function loop(body, names) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(names) ?\n      body :\n      (body = \"\" + (isNil(body) ?\n        \"\" :\n        \"\" + body + \",\\n\") + (compileTemplate(list(\"~{}: ~{}\", compile(first(names)), compile(macroexpand(form[first(names)]))))), names = rest(names), loop);\n    };\n    return recur;\n  })(void(0), keys(form));\n  return isNil(body) ?\n    \"{}\" :\n    compileTemplate(list(\"{\\n  ~{}\\n}\", body));\n};\nexports.compileDictionary = compileDictionary;\n\nvar desugarFnName = function desugarFnName(form) {\n  return (isSymbol(first(form))) || (isNil(first(form))) ?\n    form :\n    cons(void(0), form);\n};\nexports.desugarFnName = desugarFnName;\n\nvar desugarFnDoc = function desugarFnDoc(form) {\n  return (isString(second(form))) || (isNil(second(form))) ?\n    form :\n    cons(first(form), cons(void(0), rest(form)));\n};\nexports.desugarFnDoc = desugarFnDoc;\n\nvar desugarFnAttrs = function desugarFnAttrs(form) {\n  return (isDictionary(third(form))) || (isNil(third(form))) ?\n    form :\n    cons(first(form), cons(second(form), cons(void(0), rest(rest(form)))));\n};\nexports.desugarFnAttrs = desugarFnAttrs;\n\nvar compileDesugaredFn = function compileDesugaredFn(name, doc, attrs, params, body) {\n  return compileTemplate(isNil(name) ?\n    list(\"function(~{}) {\\n  ~{}\\n}\", join(\", \", map(compile, (params || 0)[\"names\"])), compileFnBody(map(macroexpand, body), params)) :\n    list(\"function ~{}(~{}) {\\n  ~{}\\n}\", compile(name), join(\", \", map(compile, (params || 0)[\"names\"])), compileFnBody(map(macroexpand, body), params)));\n};\nexports.compileDesugaredFn = compileDesugaredFn;\n\nvar compileStatements = function compileStatements(form, prefix) {\n  return (function loop(result, expression, expressions) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(expressions) ?\n      \"\" + result + (isNil(prefix) ?\n        \"\" :\n        prefix) + (compile(macroexpand(expression))) + \";\" :\n      (result = \"\" + result + (compile(macroexpand(expression))) + \";\\n\", expression = first(expressions), expressions = rest(expressions), loop);\n    };\n    return recur;\n  })(\"\", first(form), rest(form));\n};\nexports.compileStatements = compileStatements;\n\nvar compileFnBody = function compileFnBody(form, params) {\n  return (isDictionary(params)) && ((params || 0)[\"rest\"]) ?\n    compileStatements(cons(list(symbol(void(0), \"def\"), (params || 0)[\"rest\"], list(symbol(void(0), \"Array.prototype.slice.call\"), symbol(void(0), \"arguments\"), (params || 0)[\"arity\"])), form), \"return \") :\n  (count(form) === 1) && (isList(first(form))) && (isEqual(first(first(form)), symbol(void(0), \"do\"))) ?\n    compileFnBody(rest(first(form)), params) :\n    compileStatements(form, \"return \");\n};\nexports.compileFnBody = compileFnBody;\n\nvar desugarParams = function desugarParams(params) {\n  return (function loop(names, params) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(params) ?\n      {\n        \"names\": names,\n        \"arity\": count(names),\n        \"rest\": void(0)\n      } :\n    isEqual(first(params), symbol(void(0), \"&\")) ?\n      isEqual(count(params), 1) ?\n        {\n          \"names\": names,\n          \"arity\": count(names),\n          \"rest\": void(0)\n        } :\n      isEqual(count(params), 2) ?\n        {\n          \"names\": names,\n          \"arity\": count(names),\n          \"rest\": second(params)\n        } :\n      \"else\" ?\n        (function() { throw TypeError(\"Unexpected number of parameters after &\"); })() :\n        void(0) :\n    \"else\" ?\n      (names = conj(names, first(params)), params = rest(params), loop) :\n      void(0);\n    };\n    return recur;\n  })([], params);\n};\nexports.desugarParams = desugarParams;\n\nvar analyzeOverloadedFn = function analyzeOverloadedFn(name, doc, attrs, overloads) {\n  return map(function(overload) {\n    var params = desugarParams(first(overload));\n    return {\n      \"rest\": (params || 0)[\"rest\"],\n      \"names\": (params || 0)[\"names\"],\n      \"arity\": (params || 0)[\"arity\"],\n      \"body\": rest(overload)\n    };\n  }, overloads);\n};\nexports.analyzeOverloadedFn = analyzeOverloadedFn;\n\nvar compileOverloadedFn = function compileOverloadedFn(name, doc, attrs, overloads) {\n  var methods = analyzeOverloadedFn(name, doc, attrs, overloads);\n  var fixedMethods = filter(function(method) {\n    return !((method || 0)[\"rest\"]);\n  }, methods);\n  var variadic = first(filter(function(method) {\n    return (method || 0)[\"rest\"];\n  }, methods));\n  var names = reduce(function(names, params) {\n    return count(names) > (params || 0)[\"arity\"] ?\n      names :\n      (params || 0)[\"names\"];\n  }, [], methods);\n  return list(symbol(void(0), \"fn\"), name, doc, attrs, names, list(symbol(void(0), \"raw*\"), compileSwitch(symbol(void(0), \"arguments.length\"), map(function(method) {\n    return cons((method || 0)[\"arity\"], list(symbol(void(0), \"raw*\"), compileFnBody(concat(compileRebind(names, (method || 0)[\"names\"]), (method || 0)[\"body\"]))));\n  }, fixedMethods), isNil(variadic) ?\n    list(symbol(void(0), \"throw\"), list(symbol(void(0), \"Error\"), \"Invalid arity\")) :\n    list(symbol(void(0), \"raw*\"), compileFnBody(concat(compileRebind(cons(list(symbol(void(0), \"Array.prototype.slice.call\"), symbol(void(0), \"arguments\"), (variadic || 0)[\"arity\"]), names), cons((variadic || 0)[\"rest\"], (variadic || 0)[\"names\"])), (variadic || 0)[\"body\"]))))), void(0));\n};\nexports.compileOverloadedFn = compileOverloadedFn;\n\nvar compileRebind = function compileRebind(bindings, names) {\n  return (function loop(form, bindings, names) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(names) ?\n      reverse(form) :\n      (form = isEqual(first(names), first(bindings)) ?\n        form :\n        cons(list(symbol(void(0), \"def\"), first(names), first(bindings)), form), bindings = rest(bindings), names = rest(names), loop);\n    };\n    return recur;\n  })(list(), bindings, names);\n};\nexports.compileRebind = compileRebind;\n\nvar compileSwitchCases = function compileSwitchCases(cases) {\n  return reduce(function(form, caseExpression) {\n    return \"\" + form + (compileTemplate(list(\"case ~{}:\\n  ~{}\\n\", compile(macroexpand(first(caseExpression))), compile(macroexpand(rest(caseExpression))))));\n  }, \"\", cases);\n};\nexports.compileSwitchCases = compileSwitchCases;\n\nvar compileSwitch = function compileSwitch(value, cases, defaultCase) {\n  return compileTemplate(list(\"switch (~{}) {\\n  ~{}\\n  default:\\n    ~{}\\n}\", compile(macroexpand(value)), compileSwitchCases(cases), compile(macroexpand(defaultCase))));\n};\nexports.compileSwitch = compileSwitch;\n\nvar compileFn = function compileFn(form) {\n  var signature = desugarFnAttrs(desugarFnDoc(desugarFnName(form)));\n  var name = first(signature);\n  var doc = second(signature);\n  var attrs = third(signature);\n  return isVector(third(rest(signature))) ?\n    compileDesugaredFn(name, doc, attrs, desugarParams(third(rest(signature))), rest(rest(rest(rest(signature))))) :\n    compile(compileOverloadedFn(name, doc, attrs, rest(rest(rest(signature)))));\n};\nexports.compileFn = compileFn;\n\nvar compileInvoke = function compileInvoke(form) {\n  return compileTemplate(list(isList(first(form)) ?\n    \"(~{})(~{})\" :\n    \"~{}(~{})\", compile(first(form)), compileGroup(rest(form))));\n};\nexports.compileInvoke = compileInvoke;\n\nvar compileGroup = function compileGroup(form, wrap) {\n  return wrap ?\n    \"\" + \"(\" + (compileGroup(form)) + \")\" :\n    join(\", \", vec(map(compile, map(macroexpand, form))));\n};\nexports.compileGroup = compileGroup;\n\nvar compileDo = function compileDo(form) {\n  return compile(list(cons(symbol(void(0), \"fn\"), cons([], form))));\n};\nexports.compileDo = compileDo;\n\nvar defineBindings = function defineBindings(form) {\n  return (function loop(defs, bindings) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = count(bindings) === 0 ?\n      reverse(defs) :\n      (defs = cons(list(symbol(void(0), \"def\"), bindings[0], bindings[1]), defs), bindings = rest(rest(bindings)), loop);\n    };\n    return recur;\n  })(list(), form);\n};\nexports.defineBindings = defineBindings;\n\nvar compileThrow = function compileThrow(form) {\n  return compileTemplate(list(\"(function() { throw ~{}; })()\", compile(macroexpand(first(form)))));\n};\nexports.compileThrow = compileThrow;\n\nvar compileSet = function compileSet(form) {\n  return compileTemplate(list(\"~{} = ~{}\", compile(macroexpand(first(form))), compile(macroexpand(second(form)))));\n};\nexports.compileSet = compileSet;\n\nvar compileVector = function compileVector(form) {\n  return compileTemplate(list(\"[~{}]\", compileGroup(form)));\n};\nexports.compileVector = compileVector;\n\nvar compileTry = function compileTry(form) {\n  return (function loop(tryExprs, catchExprs, finallyExprs, exprs) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(exprs) ?\n      isEmpty(catchExprs) ?\n        compileTemplate(list(\"(function() {\\ntry {\\n  ~{}\\n} finally {\\n  ~{}\\n}})()\", compileFnBody(tryExprs), compileFnBody(finallyExprs))) :\n      isEmpty(finallyExprs) ?\n        compileTemplate(list(\"(function() {\\ntry {\\n  ~{}\\n} catch (~{}) {\\n  ~{}\\n}})()\", compileFnBody(tryExprs), compile(first(catchExprs)), compileFnBody(rest(catchExprs)))) :\n        compileTemplate(list(\"(function() {\\ntry {\\n  ~{}\\n} catch (~{}) {\\n  ~{}\\n} finally {\\n  ~{}\\n}})()\", compileFnBody(tryExprs), compile(first(catchExprs)), compileFnBody(rest(catchExprs)), compileFnBody(finallyExprs))) :\n    isEqual(first(first(exprs)), symbol(void(0), \"catch\")) ?\n      (tryExprs = tryExprs, catchExprs = rest(first(exprs)), finallyExprs = finallyExprs, exprs = rest(exprs), loop) :\n    isEqual(first(first(exprs)), symbol(void(0), \"finally\")) ?\n      (tryExprs = tryExprs, catchExprs = catchExprs, finallyExprs = rest(first(exprs)), exprs = rest(exprs), loop) :\n      (tryExprs = cons(first(exprs), tryExprs), catchExprs = catchExprs, finallyExprs = finallyExprs, exprs = rest(exprs), loop);\n    };\n    return recur;\n  })(list(), list(), list(), reverse(form));\n};\nexports.compileTry = compileTry;\n\nvar compileProperty = function compileProperty(form) {\n  return (name(second(form)))[0] === \"-\" ?\n    compileTemplate(list(isList(first(form)) ?\n      \"(~{}).~{}\" :\n      \"~{}.~{}\", compile(macroexpand(first(form))), compile(macroexpand(symbol(subs(name(second(form)), 1)))))) :\n    compileTemplate(list(\"~{}.~{}(~{})\", compile(macroexpand(first(form))), compile(macroexpand(second(form))), compileGroup(rest(rest(form)))));\n};\nexports.compileProperty = compileProperty;\n\nvar compileApply = function compileApply(form) {\n  return compile(list(symbol(void(0), \".\"), first(form), symbol(void(0), \"apply\"), first(form), second(form)));\n};\nexports.compileApply = compileApply;\n\nvar compileNew = function compileNew(form) {\n  return compileTemplate(list(\"new ~{}\", compile(form)));\n};\nexports.compileNew = compileNew;\n\nvar compileCompoundAccessor = function compileCompoundAccessor(form) {\n  var target = macroexpand(first(form));\n  var attribute = macroexpand(second(form));\n  var template = isList(target) ?\n    \"(~{})[~{}]\" :\n    \"~{}[~{}]\";\n  return compileTemplate(list(template, compile(target), compile(attribute)));\n};\nexports.compileCompoundAccessor = compileCompoundAccessor;\n\nvar compileInstance = function compileInstance(form) {\n  return compileTemplate(list(\"~{} instanceof ~{}\", compile(macroexpand(second(form))), compile(macroexpand(first(form)))));\n};\nexports.compileInstance = compileInstance;\n\nvar compileNot = function compileNot(form) {\n  return compileTemplate(list(\"!(~{})\", compile(macroexpand(first(form)))));\n};\nexports.compileNot = compileNot;\n\nvar compileLoop = function compileLoop(form) {\n  var bindings = (function loop(names, values, tokens) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(tokens) ?\n      {\n        \"names\": names,\n        \"values\": values\n      } :\n      (names = conj(names, first(tokens)), values = conj(values, second(tokens)), tokens = rest(rest(tokens)), loop);\n    };\n    return recur;\n  })([], [], first(form));\n  var names = (bindings || 0)[\"names\"];\n  var values = (bindings || 0)[\"values\"];\n  var body = rest(form);\n  return compile(cons(cons(symbol(void(0), \"fn\"), cons(symbol(void(0), \"loop\"), cons(names, compileRecur(names, body)))), list.apply(list, values)));\n};\nexports.compileLoop = compileLoop;\n\nvar rebindBindings = function rebindBindings(names, values) {\n  return (function loop(result, names, values) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(names) ?\n      reverse(result) :\n      (result = cons(list(symbol(void(0), \"set!\"), first(names), first(values)), result), names = rest(names), values = rest(values), loop);\n    };\n    return recur;\n  })(list(), names, values);\n};\nexports.rebindBindings = rebindBindings;\n\nvar expandRecur = function expandRecur(names, body) {\n  return map(function(form) {\n    return isList(form) ?\n      isEqual(first(form), symbol(void(0), \"recur\")) ?\n        list(symbol(void(0), \"raw*\"), compileGroup(concat(rebindBindings(names, rest(form)), list(symbol(void(0), \"loop\"))), true)) :\n        expandRecur(names, form) :\n      form;\n  }, body);\n};\nexports.expandRecur = expandRecur;\n\nvar compileRecur = function compileRecur(names, body) {\n  return list(list(symbol(void(0), \"raw*\"), compileTemplate(list(\"var recur = loop;\\nwhile (recur === loop) {\\n  recur = ~{}\\n}\", compileStatements(expandRecur(names, body))))), symbol(void(0), \"recur\"));\n};\nexports.compileRecur = compileRecur;\n\nvar compileRaw = function compileRaw(form) {\n  return first(form);\n};\nexports.compileRaw = compileRaw;\n\ninstallSpecial(symbol(void(0), \"set!\"), compileSet);\n\ninstallSpecial(symbol(void(0), \"get\"), compileCompoundAccessor);\n\ninstallSpecial(symbol(void(0), \"aget\"), compileCompoundAccessor);\n\ninstallSpecial(symbol(void(0), \"def\"), compileDef);\n\ninstallSpecial(symbol(void(0), \"if\"), compileIfElse);\n\ninstallSpecial(symbol(void(0), \"do\"), compileDo);\n\ninstallSpecial(symbol(void(0), \"do*\"), compileStatements);\n\ninstallSpecial(symbol(void(0), \"fn\"), compileFn);\n\ninstallSpecial(symbol(void(0), \"throw\"), compileThrow);\n\ninstallSpecial(symbol(void(0), \"vector\"), compileVector);\n\ninstallSpecial(symbol(void(0), \"try\"), compileTry);\n\ninstallSpecial(symbol(void(0), \".\"), compileProperty);\n\ninstallSpecial(symbol(void(0), \"apply\"), compileApply);\n\ninstallSpecial(symbol(void(0), \"new\"), compileNew);\n\ninstallSpecial(symbol(void(0), \"instance?\"), compileInstance);\n\ninstallSpecial(symbol(void(0), \"not\"), compileNot);\n\ninstallSpecial(symbol(void(0), \"loop\"), compileLoop);\n\ninstallSpecial(symbol(void(0), \"raw*\"), compileRaw);\n\ninstallSpecial(symbol(void(0), \"comment\"), writeComment);\n\nvar compileRePattern = function compileRePattern(form) {\n  return \"\" + form;\n};\nexports.compileRePattern = compileRePattern;\n\nvar installNative = function installNative(alias, operator, validator, fallback) {\n  return installSpecial(alias, function(form) {\n    return isEmpty(form) ?\n      fallback :\n      reduce(function(left, right) {\n        return compileTemplate(list(\"~{} ~{} ~{}\", left, name(operator), right));\n      }, map(function(operand) {\n        return compileTemplate(list(isList(operand) ?\n          \"(~{})\" :\n          \"~{}\", compile(macroexpand(operand))));\n      }, form));\n  }, validator);\n};\nexports.installNative = installNative;\n\nvar installOperator = function installOperator(alias, operator) {\n  return installSpecial(alias, function(form) {\n    return (function loop(result, left, right, operands) {\n      var recur = loop;\n      while (recur === loop) {\n        recur = isEmpty(operands) ?\n        \"\" + result + (compileTemplate(list(\"~{} ~{} ~{}\", compile(macroexpand(left)), name(operator), compile(macroexpand(right))))) :\n        (result = \"\" + result + (compileTemplate(list(\"~{} ~{} ~{} && \", compile(macroexpand(left)), name(operator), compile(macroexpand(right))))), left = right, right = first(operands), operands = rest(operands), loop);\n      };\n      return recur;\n    })(\"\", first(form), second(form), rest(rest(form)));\n  }, verifyTwo);\n};\nexports.installOperator = installOperator;\n\nvar compilerError = function compilerError(form, message) {\n  var error = Error(\"\" + message);\n  error.line = 1;\n  return (function() { throw error; })();\n};\nexports.compilerError = compilerError;\n\nvar verifyTwo = function verifyTwo(form) {\n  return (isEmpty(rest(form))) || (isEmpty(rest(rest(form)))) ?\n    (function() { throw compilerError(form, \"\" + (first(form)) + \" form requires at least two operands\"); })() :\n    void(0);\n};\nexports.verifyTwo = verifyTwo;\n\ninstallNative(symbol(void(0), \"+\"), symbol(void(0), \"+\"), void(0), 0);\n\ninstallNative(symbol(void(0), \"-\"), symbol(void(0), \"-\"), void(0), \"NaN\");\n\ninstallNative(symbol(void(0), \"*\"), symbol(void(0), \"*\"), void(0), 1);\n\ninstallNative(symbol(void(0), \"/\"), symbol(void(0), \"/\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"mod\"), symbol(\"%\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"and\"), symbol(void(0), \"&&\"));\n\ninstallNative(symbol(void(0), \"or\"), symbol(void(0), \"||\"));\n\ninstallOperator(symbol(void(0), \"not=\"), symbol(void(0), \"!=\"));\n\ninstallOperator(symbol(void(0), \"==\"), symbol(void(0), \"===\"));\n\ninstallOperator(symbol(void(0), \"identical?\"), symbol(void(0), \"===\"));\n\ninstallOperator(symbol(void(0), \">\"), symbol(void(0), \">\"));\n\ninstallOperator(symbol(void(0), \">=\"), symbol(void(0), \">=\"));\n\ninstallOperator(symbol(void(0), \"<\"), symbol(void(0), \"<\"));\n\ninstallOperator(symbol(void(0), \"<=\"), symbol(void(0), \"<=\"));\n\ninstallNative(symbol(void(0), \"bit-and\"), symbol(void(0), \"&\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-or\"), symbol(void(0), \"|\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-xor\"), symbol(\"^\"));\n\ninstallNative(symbol(void(0), \"bit-not\"), symbol(\"~\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-shift-left\"), symbol(void(0), \"<<\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-shift-right\"), symbol(void(0), \">>\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-shift-right-zero-fil\"), symbol(void(0), \">>>\"), verifyTwo);\n\ninstallMacro(symbol(void(0), \"str\"), function str() {\n  var forms = Array.prototype.slice.call(arguments, 0);\n  return concat(list(symbol(void(0), \"+\"), \"\"), forms);\n});\n\ninstallMacro(symbol(void(0), \"let\"), function letMacro(bindings) {\n  var body = Array.prototype.slice.call(arguments, 1);\n  return cons(symbol(void(0), \"do\"), concat(defineBindings(bindings), body));\n});\n\ninstallMacro(symbol(void(0), \"cond\"), function cond() {\n  var clauses = Array.prototype.slice.call(arguments, 0);\n  return !(isEmpty(clauses)) ?\n    list(symbol(void(0), \"if\"), first(clauses), isEmpty(rest(clauses)) ?\n      (function() { throw Error(\"cond requires an even number of forms\"); })() :\n      second(clauses), cons(symbol(void(0), \"cond\"), rest(rest(clauses)))) :\n    void(0);\n});\n\ninstallMacro(symbol(void(0), \"defn\"), function defn(name) {\n  var body = Array.prototype.slice.call(arguments, 1);\n  return list(symbol(void(0), \"def\"), name, concat(list(symbol(void(0), \"fn\"), name), body));\n});\n\ninstallMacro(symbol(void(0), \"defn-\"), function defn(name) {\n  var body = Array.prototype.slice.call(arguments, 1);\n  return concat(list(symbol(void(0), \"defn\"), withMeta(name, conj({\n    \"private\": true\n  }, meta(name)))), body);\n});\n\ninstallMacro(symbol(void(0), \"assert\"), function assert(x, message) {\n  var title = message || \"\";\n  var assertion = prStr(x);\n  var uri = (x || 0)[\"uri\"];\n  var form = isList(x) ?\n    second(x) :\n    x;\n  return list(symbol(void(0), \"do\"), list(symbol(void(0), \"if\"), list(symbol(void(0), \"and\"), list(symbol(void(0), \"not\"), list(symbol(void(0), \"identical?\"), list(symbol(void(0), \"typeof\"), symbol(void(0), \"**verbose**\")), \"undefined\")), symbol(void(0), \"**verbose**\")), list(symbol(void(0), \".log\"), symbol(void(0), \"console\"), \"Assert:\", assertion)), list(symbol(void(0), \"if\"), list(symbol(void(0), \"not\"), x), list(symbol(void(0), \"throw\"), list(symbol(void(0), \"Error.\"), list(symbol(void(0), \"str\"), \"Assert failed: \", title, \"\\n\\nAssertion:\\n\\n\", assertion, \"\\n\\nActual:\\n\\n\", form, \"\\n--------------\\n\"), uri))));\n});\n\ninstallMacro(symbol(void(0), \"import\"), function(imports, path) {\n  return isNil(path) ?\n    list(symbol(void(0), \"require\"), imports) :\n  isSymbol(imports) ?\n    list(symbol(void(0), \"def\"), withMeta(imports, {\n      \"private\": true\n    }), list(symbol(void(0), \"require\"), path)) :\n    (function loop(form, names) {\n      var recur = loop;\n      while (recur === loop) {\n        recur = isEmpty(names) ?\n        concat(list(symbol(void(0), \"do*\")), form) :\n        (function() {\n          var alias = first(names);\n          var id = symbol(\"\" + \".-\" + (name(alias)));\n          return (form = cons(list(symbol(void(0), \"def\"), withMeta(alias, {\n            \"private\": true\n          }), list(id, list(symbol(void(0), \"require\"), path))), form), names = rest(names), loop);\n        })();\n      };\n      return recur;\n    })(list(), imports);\n})\n\n//@ sourceURL=/lib/compiler.js"
));

require.define("/lib/backend/javascript/writer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var isKeyword = (require(\"../../ast\")).isKeyword;\nvar isSymbol = (require(\"../../ast\")).isSymbol;\nvar symbol = (require(\"../../ast\")).symbol;\nvar namespace = (require(\"../../ast\")).namespace;\nvar name = (require(\"../../ast\")).name;;\n\nvar isEmpty = (require(\"../../sequence\")).isEmpty;\nvar reduce = (require(\"../../sequence\")).reduce;\nvar last = (require(\"../../sequence\")).last;\nvar count = (require(\"../../sequence\")).count;\nvar map = (require(\"../../sequence\")).map;\nvar vec = (require(\"../../sequence\")).vec;\nvar isList = (require(\"../../sequence\")).isList;\nvar rest = (require(\"../../sequence\")).rest;\nvar first = (require(\"../../sequence\")).first;\nvar list = (require(\"../../sequence\")).list;;\n\nvar subs = (require(\"../../runtime\")).subs;\nvar dec = (require(\"../../runtime\")).dec;\nvar reFind = (require(\"../../runtime\")).reFind;\nvar isRePattern = (require(\"../../runtime\")).isRePattern;\nvar isBoolean = (require(\"../../runtime\")).isBoolean;\nvar isDictionary = (require(\"../../runtime\")).isDictionary;\nvar isVector = (require(\"../../runtime\")).isVector;\nvar isNumber = (require(\"../../runtime\")).isNumber;\nvar isString = (require(\"../../runtime\")).isString;\nvar isNil = (require(\"../../runtime\")).isNil;\nvar isTrue = (require(\"../../runtime\")).isTrue;;\n\nvar upperCase = (require(\"../../string\")).upperCase;\nvar split = (require(\"../../string\")).split;\nvar join = (require(\"../../string\")).join;\nvar replace = (require(\"../../string\")).replace;;\n\nvar writeReference = function writeReference(form) {\n  \"Translates references from clojure convention to JS:\\n\\n  **macros**      __macros__\\n  list->vector    listToVector\\n  set!            set\\n  foo_bar         foo_bar\\n  number?         isNumber\\n  create-server   createServer\";\n  return (function() {\n    var id = name(form);\n    id = id === \"*\" ?\n      \"multiply\" :\n    id === \"/\" ?\n      \"divide\" :\n    id === \"+\" ?\n      \"sum\" :\n    id === \"-\" ?\n      \"subtract\" :\n    id === \"=\" ?\n      \"equal?\" :\n    id === \"==\" ?\n      \"strict-equal?\" :\n    id === \"<=\" ?\n      \"not-greater-than\" :\n    id === \">=\" ?\n      \"not-less-than\" :\n    id === \">\" ?\n      \"greater-than\" :\n    id === \"<\" ?\n      \"less-than\" :\n    \"else\" ?\n      id :\n      void(0);\n    id = join(\"_\", split(id, \"*\"));\n    id = join(\"-to-\", split(id, \"->\"));\n    id = join(split(id, \"!\"));\n    id = join(\"$\", split(id, \"%\"));\n    id = join(\"-plus-\", split(id, \"+\"));\n    id = join(\"-and-\", split(id, \"&\"));\n    id = last(id) === \"?\" ?\n      \"\" + \"is-\" + (subs(id, 0, dec(count(id)))) :\n      id;\n    id = reduce(function(result, key) {\n      return \"\" + result + ((!(isEmpty(result))) && (!(isEmpty(key))) ?\n        \"\" + (upperCase(key[0])) + (subs(key, 1)) :\n        key);\n    }, \"\", split(id, \"-\"));\n    return id;\n  })();\n};\nexports.writeReference = writeReference;\n\nvar writeKeywordReference = function writeKeywordReference(form) {\n  return \"\" + \"\\\"\" + (name(form)) + \"\\\"\";\n};\nexports.writeKeywordReference = writeKeywordReference;\n\nvar writeKeyword = function writeKeyword(form) {\n  return \"\" + \"\\\"\" + \"ê\" + (name(form)) + \"\\\"\";\n};\nexports.writeKeyword = writeKeyword;\n\nvar writeSymbol = function writeSymbol(form) {\n  return write(list(symbol(void(0), \"symbol\"), namespace(form), name(form)));\n};\nexports.writeSymbol = writeSymbol;\n\nvar writeNil = function writeNil(form) {\n  return \"void(0)\";\n};\nexports.writeNil = writeNil;\n\nvar writeNumber = function writeNumber(form) {\n  return form;\n};\nexports.writeNumber = writeNumber;\n\nvar writeBoolean = function writeBoolean(form) {\n  return isTrue(form) ?\n    \"true\" :\n    \"false\";\n};\nexports.writeBoolean = writeBoolean;\n\nvar writeString = function writeString(form) {\n  form = replace(form, RegExp(\"\\\\\\\\\", \"g\"), \"\\\\\\\\\");\n  form = replace(form, RegExp(\"\\n\", \"g\"), \"\\\\n\");\n  form = replace(form, RegExp(\"\\r\", \"g\"), \"\\\\r\");\n  form = replace(form, RegExp(\"\\t\", \"g\"), \"\\\\t\");\n  form = replace(form, RegExp(\"\\\"\", \"g\"), \"\\\\\\\"\");\n  return \"\" + \"\\\"\" + form + \"\\\"\";\n};\nexports.writeString = writeString;\n\nvar writeTemplate = function writeTemplate() {\n  var form = Array.prototype.slice.call(arguments, 0);\n  return (function() {\n    var indentPattern = /\\n *$/;\n    var lineBreakPatter = RegExp(\"\\n\", \"g\");\n    var getIndentation = function(code) {\n      return (reFind(indentPattern, code)) || \"\\n\";\n    };\n    return (function loop(code, parts, values) {\n      var recur = loop;\n      while (recur === loop) {\n        recur = count(parts) > 1 ?\n        (code = \"\" + code + (first(parts)) + (replace(\"\" + \"\" + (first(values)), lineBreakPatter, getIndentation(first(parts)))), parts = rest(parts), values = rest(values), loop) :\n        \"\" + code + (first(parts));\n      };\n      return recur;\n    })(\"\", split(first(form), \"~{}\"), rest(form));\n  })();\n};\nexports.writeTemplate = writeTemplate;\n\nvar writeGroup = function writeGroup() {\n  var forms = Array.prototype.slice.call(arguments, 0);\n  return join(\", \", forms);\n};\nexports.writeGroup = writeGroup;\n\nvar writeInvoke = function writeInvoke(callee) {\n  var params = Array.prototype.slice.call(arguments, 1);\n  return writeTemplate(\"~{}(~{})\", callee, writeGroup.apply(writeGroup, params));\n};\nexports.writeInvoke = writeInvoke;\n\nvar writeError = function writeError(message) {\n  return function() {\n    return (function() { throw Error(message); })();\n  };\n};\nexports.writeError = writeError;\n\nvar writeVector = writeError(\"Vectors are not supported\");\nexports.writeVector = writeVector;\n\nvar writeDictionary = writeError(\"Dictionaries are not supported\");\nexports.writeDictionary = writeDictionary;\n\nvar writePattern = writeError(\"Regular expressions are not supported\");\nexports.writePattern = writePattern;\n\nvar compileComment = function compileComment(form) {\n  return compileTemplate(list(\"//~{}\\n\", first(form)));\n};\nexports.compileComment = compileComment;\n\nvar writeDef = function writeDef(form) {\n  var id = first(form);\n  var isExport = ((((meta(form)) || {}) || 0)[\"top\"]) && (!((((meta(id)) || {}) || 0)[\"private\"]));\n  var attribute = symbol(namespace(id), \"\" + \"-\" + (name(id)));\n  return isExport ?\n    compileTemplate(list(\"var ~{};\\n~{}\", compile(cons(symbol(void(0), \"set!\"), form)), compile(list(symbol(void(0), \"set!\"), list(symbol(void(0), \".\"), symbol(void(0), \"exports\"), attribute), id)))) :\n    compileTemplate(list(\"var ~{}\", compile(cons(symbol(void(0), \"set!\"), form))));\n};\nexports.writeDef = writeDef;\n\nvar write = function write(form) {\n  return isNil(form) ?\n    writeNil(form) :\n  isSymbol(form) ?\n    writeReference(form) :\n  isKeyword(form) ?\n    writeKeywordReference(form) :\n  isString(form) ?\n    writeString(form) :\n  isNumber(form) ?\n    writeNumber(form) :\n  isBoolean(form) ?\n    writeBoolean(form) :\n  isRePattern(form) ?\n    writePattern(form) :\n  isVector(form) ?\n    writeVector(form) :\n  isDictionary(form) ?\n    writeDictionary() :\n  isList(form) ?\n    writeInvoke.apply(writeInvoke, map(write, vec(form))) :\n  \"else\" ?\n    writeError(\"Unsupported form\") :\n    void(0);\n};\nexports.write = write\n\n//@ sourceURL=/lib/backend/javascript/writer.js"
));

require.define("/interactivate/node_modules/codemirror-hashare/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/interactivate/node_modules/codemirror-hashare/package.json"
));

require.define("/interactivate/node_modules/codemirror-hashare/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar save = \"save@hashare\"\nvar load = \"load@hashare\"\n\nfunction plugin(CodeMirror) {\n  CodeMirror.defineOption(\"hashare\", false, function(editor, value) {\n    /**\n    Takes editor and enables persists changes to the buffer across the sessions.\n    **/\n    if (value) {\n      var saving = false\n      editor[save] = function(event) {\n        location.hash = encodeURIComponent(editor.getValue())\n      }\n      editor[load] = function() {\n        var value = decodeURIComponent(window.location.hash.substr(1))\n        if (value && value !== editor.getValue()) editor.setValue(value)\n      }\n      window.addEventListener(\"blur\", editor[save], false)\n      window.addEventListener(\"hashchange\", editor[load], false)\n\n      editor[load]()\n    } else {\n      window.removeEventListener(\"blur\", editor[save], false)\n      window.removeEventListener(\"blur\", editor[load], false)\n    }\n  })\n}\n\nmodule.exports = plugin\n\n//@ sourceURL=/interactivate/node_modules/codemirror-hashare/core.js"
));

require.define("/interactivate/node_modules/codemirror-persist/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/interactivate/node_modules/codemirror-persist/package.json"
));

require.define("/interactivate/node_modules/codemirror-persist/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nfunction onChange(editor) {\n  localStorage[window.location.href.split(\"#\")[0]] = editor.getValue()\n}\n\nfunction setup(editor, value) {\n  /**\n  Takes editor and enables persists changes to the buffer across the sessions.\n  **/\n  if (value) {\n    var address = window.location.href.split(\"#\")[0]\n    var persisted = localStorage[address] || editor.getValue()\n    editor.setValue(persisted)\n    editor.on(\"change\", onChange)\n  } else {\n    editor.off(\"change\", onChange)\n  }\n}\n\nfunction plugin(CodeMirror) {\n  CodeMirror.defineOption(\"persist\", false, setup)\n}\n\nmodule.exports = plugin\n\n//@ sourceURL=/interactivate/node_modules/codemirror-persist/core.js"
));

require.define("/interactivate/node_modules/codemirror-activine/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/interactivate/node_modules/codemirror-activine/package.json"
));

require.define("/interactivate/node_modules/codemirror-activine/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar activeLine = \"line@activine\"\n\nfunction onCursorActivity(editor) {\n  var line = editor.getLineHandle(editor.getCursor().line)\n  var active = editor[activeLine]\n  if (line != active) {\n    editor.removeLineClass(active, \"background\", \"activeline\")\n    editor[activeLine] = editor.addLineClass(line, \"background\", \"activeline\")\n  }\n}\n\nfunction setup(editor, value) {\n  /**\n  Takes editor and enables persists changes to the buffer across the sessions.\n  **/\n  if (value) {\n    editor[activeLine] = editor.addLineClass(0, \"background\", \"activeline\")\n    editor.on(\"cursorActivity\", onCursorActivity)\n    onCursorActivity(editor)\n  } else {\n    editor.removeLineClass(editor[activeLine], \"background\", \"activeline\")\n    delete editor[activeLine]\n    editor.off(\"cursorActivity\", onCursorActivity)\n  }\n}\n\nfunction plugin(CodeMirror) {\n  CodeMirror.defineOption(\"activeLine\", false, setup)\n}\n\nmodule.exports = plugin\n\n//@ sourceURL=/interactivate/node_modules/codemirror-activine/core.js"
));

require.define("/interactivate/main.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var interactivate = require(\"interactivate\");\n\nvar startHost = (require(\"./host\")).startHost;;\n\nvar hashare = require(\"codemirror-hashare\");\n\nvar persist = require(\"codemirror-persist\");\n\nvar activine = require(\"codemirror-activine\");\n\ninteractivate(CodeMirror);\n\nactivine(CodeMirror);\n\nhashare(CodeMirror);\n\npersist(CodeMirror);\n\nstartHost();\n\nvar editor = CodeMirror(document.body, {\n  \"persist\": true,\n  \"matchBrackets\": true,\n  \"electricChars\": true,\n  \"activeLine\": true,\n  \"autofocus\": true,\n  \"theme\": \"solarized dark\",\n  \"mode\": \"clojure\",\n  \"interactivate\": true,\n  \"interactiveSeparator\": /^;; =>[^\\n]*$/m,\n  \"extraKeys\": {\n    \"Tab\": \"indentSelection\"\n  }\n});\nexports.editor = editor;\n\nglobal.editor = editor\n\n//@ sourceURL=/interactivate/main.js"
));
require("/interactivate/main.js");

